From 49f11944af03f34b2ea9c15484fc5492f64eb52e Mon Sep 17 00:00:00 2001
From: Lei Deng <denglei@eswincomputing.com>
Date: Thu, 23 May 2024 13:43:49 +0800
Subject: [PATCH 048/128] feat:Porting hdmi driver to linux 6.6.

Signed-off-by: Lei Deng <denglei@eswincomputing.com>
---
 .../dts/eswin/eic7700-hifive-premier-p550.dts |    1 -
 .../configs/hifive-premier-p550_defconfig     |    4 +-
 drivers/gpu/drm/eswin/Kconfig                 |    2 +-
 drivers/gpu/drm/eswin/Makefile                |    2 +-
 .../gpu/drm/eswin/{dw_hdmi.c => dw-hdmi.c}    | 1202 +++++++-------
 drivers/gpu/drm/eswin/dw-hdmi.h               | 1272 +++++++++++++++
 drivers/gpu/drm/eswin/dw_hdmi.h               | 1408 -----------------
 drivers/gpu/drm/eswin/dw_hdmi_hdcp.c          |    7 +-
 drivers/gpu/drm/eswin/dw_hdmi_hdcp.h          |    1 -
 drivers/gpu/drm/eswin/dw_hdmi_hdcp2.c         |    4 +-
 drivers/gpu/drm/eswin/dw_hdmi_i2s_audio.c     |   65 +-
 drivers/gpu/drm/eswin/es_drv.c                |    4 +-
 drivers/gpu/drm/eswin/eswin_dw_hdmi.c         |   38 +-
 include/drm/bridge/dw_hdmi.h                  |    7 +
 14 files changed, 1933 insertions(+), 2084 deletions(-)
 rename drivers/gpu/drm/eswin/{dw_hdmi.c => dw-hdmi.c} (82%)
 create mode 100644 drivers/gpu/drm/eswin/dw-hdmi.h
 delete mode 100644 drivers/gpu/drm/eswin/dw_hdmi.h

diff --git a/arch/riscv/boot/dts/eswin/eic7700-hifive-premier-p550.dts b/arch/riscv/boot/dts/eswin/eic7700-hifive-premier-p550.dts
index 880ec234d084..1113af92df6e 100644
--- a/arch/riscv/boot/dts/eswin/eic7700-hifive-premier-p550.dts
+++ b/arch/riscv/boot/dts/eswin/eic7700-hifive-premier-p550.dts
@@ -263,7 +263,6 @@ &dsi_panel {
 
 &dw_hdmi {
 	status = "okay";
-	eswin-plat = <1>;
 	ports {
 		port@2 {
 			reg = <2>;
diff --git a/arch/riscv/configs/hifive-premier-p550_defconfig b/arch/riscv/configs/hifive-premier-p550_defconfig
index efef30163fab..23ee62521fa5 100644
--- a/arch/riscv/configs/hifive-premier-p550_defconfig
+++ b/arch/riscv/configs/hifive-premier-p550_defconfig
@@ -3038,7 +3038,6 @@ CONFIG_IR_TTUSBIR=m
 CONFIG_RC_ATI_REMOTE=m
 CONFIG_RC_LOOPBACK=m
 CONFIG_RC_XBOX_DVD=m
-CONFIG_MEDIA_CEC_RC=y
 CONFIG_MEDIA_CEC_SUPPORT=y
 CONFIG_CEC_CH7322=m
 CONFIG_CEC_GPIO=m
@@ -3554,6 +3553,9 @@ CONFIG_DRM_SSD130X_SPI=m
 CONFIG_DRM_ESWIN=y
 CONFIG_ESWIN_VIRTUAL_DISPLAY=y
 CONFIG_ESWIN_MMU=y
+CONFIG_ESWIN_DW_HDMI=y
+CONFIG_DW_HDMI_I2S_AUDIO=y
+CONFIG_DW_HDMI_CEC=y
 CONFIG_FB=y
 CONFIG_FB_CIRRUS=m
 CONFIG_FB_PM2=m
diff --git a/drivers/gpu/drm/eswin/Kconfig b/drivers/gpu/drm/eswin/Kconfig
index 6a7771e6ac29..d518575e9bb3 100644
--- a/drivers/gpu/drm/eswin/Kconfig
+++ b/drivers/gpu/drm/eswin/Kconfig
@@ -66,7 +66,7 @@ config DW_HDMI_HDCP
 
 config DW_HDMI_HDCP2
     tristate "Synopsis Designware HDCP2 interface"
-    select DRM_ESWIN
+    depends on DW_HDMI_HDCP
     help
       Support the HDCP2 interface which is part of the Synopsys
       Designware HDMI block.
diff --git a/drivers/gpu/drm/eswin/Makefile b/drivers/gpu/drm/eswin/Makefile
index e84e28f388d6..099597edf619 100644
--- a/drivers/gpu/drm/eswin/Makefile
+++ b/drivers/gpu/drm/eswin/Makefile
@@ -11,7 +11,7 @@ es_drm-objs := es_dc_hw.o \
 
 es_drm-$(CONFIG_ESWIN_VIRTUAL_DISPLAY) += es_virtual.o
 es_drm-$(CONFIG_ESWIN_MMU) += es_dc_mmu.o
-es_drm-$(CONFIG_ESWIN_DW_HDMI) += eswin_dw_hdmi.o dw_hdmi.o
+es_drm-$(CONFIG_ESWIN_DW_HDMI) += eswin_dw_hdmi.o dw-hdmi.o
 
 es_drm-$(CONFIG_DW_HDMI_I2S_AUDIO) += dw_hdmi_i2s_audio.o
 es_drm-$(CONFIG_DW_HDMI_CEC) += dw_hdmi_cec.o
diff --git a/drivers/gpu/drm/eswin/dw_hdmi.c b/drivers/gpu/drm/eswin/dw-hdmi.c
similarity index 82%
rename from drivers/gpu/drm/eswin/dw_hdmi.c
rename to drivers/gpu/drm/eswin/dw-hdmi.c
index ae13cbcb6e29..71c89e7e3bb5 100644
--- a/drivers/gpu/drm/eswin/dw_hdmi.c
+++ b/drivers/gpu/drm/eswin/dw-hdmi.c
@@ -10,10 +10,11 @@
 #include <linux/delay.h>
 #include <linux/err.h>
 #include <linux/hdmi.h>
+#include <linux/i2c.h>
 #include <linux/irq.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
-#include <linux/of_device.h>
+#include <linux/of.h>
 #include <linux/pinctrl/consumer.h>
 #include <linux/regmap.h>
 #include <linux/dma-mapping.h>
@@ -21,22 +22,23 @@
 
 #include <media/cec-notifier.h>
 
-#include <uapi/linux/media-bus-format.h>
-#include <uapi/linux/videodev2.h>
+#include <linux/media-bus-format.h>
+#include <linux/videodev2.h>
 #include <linux/reset.h>
 
+#include <drm/bridge/dw_hdmi.h>
+#include <drm/display/drm_hdmi_helper.h>
+#include <drm/display/drm_scdc_helper.h>
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_bridge.h>
-#include <drm/drm_edid.h>
 #include <drm/drm_of.h>
 #include <drm/drm_print.h>
 #include <drm/drm_probe_helper.h>
-#include <drm/drm_scdc_helper.h>
 
 #include "dw_hdmi_audio.h"
 #include "dw_hdmi_cec.h"
-#include "dw_hdmi.h"
+#include "dw-hdmi.h"
 #include "dw_hdmi_hdcp.h"
 
 #define DDC_CI_ADDR 0x37
@@ -51,25 +53,12 @@
 
 static bool hpd_flag = false;
 
-enum hdmi_datamap {
-	RGB444_8B = 0x01,
-	RGB444_10B = 0x03,
-	RGB444_12B = 0x05,
-	RGB444_16B = 0x07,
-	YCbCr444_8B = 0x09,
-	YCbCr444_10B = 0x0B,
-	YCbCr444_12B = 0x0D,
-	YCbCr444_16B = 0x0F,
-	YCbCr422_8B = 0x16,
-	YCbCr422_10B = 0x14,
-	YCbCr422_12B = 0x12,
+static const u16 csc_coeff_default[3][4] = {
+	{ 0x2000, 0x0000, 0x0000, 0x0000 },
+	{ 0x0000, 0x2000, 0x0000, 0x0000 },
+	{ 0x0000, 0x0000, 0x2000, 0x0000 }
 };
 
-static const u16 csc_coeff_default[3][4] = { { 0x2000, 0x0000, 0x0000, 0x0000 },
-					     { 0x0000, 0x2000, 0x0000, 0x0000 },
-					     { 0x0000, 0x0000, 0x2000,
-					       0x0000 } };
-
 static const u16 csc_coeff_rgb_out_eitu601[3][4] = {
 	{ 0x2000, 0x6926, 0x74fd, 0x010e },
 	{ 0x2000, 0x2cdd, 0x0000, 0x7e9a },
@@ -126,11 +115,10 @@ static const u16 csc_coeff_rgb_to_yuv_10bit_eitu709[3][4] = {
 
 struct hdmi_vmode {
 	bool mdataenablepolarity;
-	unsigned int previous_pixelclock;
+
 	unsigned int mpixelclock;
 	unsigned int mpixelrepetitioninput;
 	unsigned int mpixelrepetitionoutput;
-	unsigned int previous_tmdsclock;
 	unsigned int mtmdsclock;
 };
 
@@ -146,17 +134,15 @@ struct hdmi_data_info {
 };
 
 struct dw_hdmi_i2c {
-	struct i2c_adapter adap;
+	struct i2c_adapter	adap;
 
-	struct mutex lock; /* used to serialize data transfers */
-	struct completion cmp;
-	u8 stat;
+	struct mutex		lock;	/* used to serialize data transfers */
+	struct completion	cmp;
+	u8			stat;
 
-	u8 slave_reg;
-	bool is_regaddr;
-	bool is_segment;
-	unsigned int scl_high_ns;
-	unsigned int scl_low_ns;
+	u8			slave_reg;
+	bool			is_regaddr;
+	bool			is_segment;
 };
 
 struct dw_hdmi_phy_data {
@@ -180,7 +166,6 @@ struct dw_hdmi {
 	struct platform_device *cec;
 	struct device *dev;
 	struct clk *isfr_clk;
-	struct clk *hclk_vio;
 	struct clk *iahb_clk;
 	struct clk *cec_clk;
 	struct dw_hdmi_i2c *i2c;
@@ -211,23 +196,25 @@ struct dw_hdmi {
 	struct pinctrl_state *default_state;
 	struct pinctrl_state *unwedge_state;
 
-	struct mutex mutex; /* for state below and previous_mode */
-	enum drm_connector_force force; /* mutex-protected force state */
-	struct drm_connector
-		*curr_conn; /* current connector (only valid when !disabled) */
-	bool disabled; /* DRM has disabled our bridge */
-	bool bridge_is_on; /* indicates the bridge is on */
-	bool rxsense; /* rxsense state */
-	u8 phy_mask; /* desired phy int mask settings */
-	u8 mc_clkdis; /* clock disable register */
+	struct mutex mutex;		/* for state below and previous_mode */
+	enum drm_connector_force force;	/* mutex-protected force state */
+	struct drm_connector *curr_conn;/* current connector (only valid when !disabled) */
+	bool disabled;			/* DRM has disabled our bridge */
+	bool bridge_is_on;		/* indicates the bridge is on */
+	bool rxsense;			/* rxsense state */
+	u8 phy_mask;			/* desired phy int mask settings */
+	u8 mc_clkdis;			/* clock disable register */
 
 	spinlock_t audio_lock;
 	struct mutex audio_mutex;
-	struct dentry *debugfs_dir;
+	unsigned int sample_non_pcm;
+	unsigned int sample_width;
 	unsigned int sample_rate;
+	unsigned int channels;
 	unsigned int audio_cts;
 	unsigned int audio_n;
 	bool audio_enable;
+	struct dentry *debugfs_dir;
 
 	unsigned int reg_shift;
 	struct regmap *regm;
@@ -247,43 +234,31 @@ struct dw_hdmi {
 	struct reset_control *rst_hdmi_prstn;
 	struct reset_control *rst_hdmi_phyrstn;
 	struct reset_control *rst_hdmi_rstn;
-
-	u32 eswin_plat;
 };
 
 #define HDMI_IH_PHY_STAT0_RX_SENSE                                             \
 	(HDMI_IH_PHY_STAT0_RX_SENSE0 | HDMI_IH_PHY_STAT0_RX_SENSE1 |           \
 	 HDMI_IH_PHY_STAT0_RX_SENSE2 | HDMI_IH_PHY_STAT0_RX_SENSE3)
 
-#define HDMI_PHY_RX_SENSE                                                      \
-	(HDMI_PHY_RX_SENSE0 | HDMI_PHY_RX_SENSE1 | HDMI_PHY_RX_SENSE2 |        \
-	 HDMI_PHY_RX_SENSE3)
+#define HDMI_PHY_RX_SENSE \
+	(HDMI_PHY_RX_SENSE0 | HDMI_PHY_RX_SENSE1 | \
+	 HDMI_PHY_RX_SENSE2 | HDMI_PHY_RX_SENSE3)
 
 static struct edid *dw_hdmi_get_edid(struct dw_hdmi *hdmi,
 				     struct drm_connector *connector);
 static void hdmi_tx_hdcp_config(struct dw_hdmi *hdmi,
-				const struct drm_display_mode *mode);
+						const struct drm_display_mode *mode);
 
 static inline void hdmi_writeb(struct dw_hdmi *hdmi, u8 val, int offset)
 {
-	int ret = regmap_write(hdmi->regm, offset << hdmi->reg_shift, val);
-	if (ret != 0) {
-		dev_err(hdmi->dev,
-			"hdmi reg write error, reg:0x%x, val:0x%x, ret:%d\n",
-			offset, val, ret);
-	}
+	regmap_write(hdmi->regm, offset << hdmi->reg_shift, val);
 }
 
 static inline u8 hdmi_readb(struct dw_hdmi *hdmi, int offset)
 {
 	unsigned int val = 0;
 
-	int ret = regmap_read(hdmi->regm, offset << hdmi->reg_shift, &val);
-	if (ret != 0) {
-		dev_err(hdmi->dev,
-			"hdmi reg read error, reg:0x%x, val:0x%x, ret:%d\n",
-			offset, val, ret);
-	}
+	regmap_read(hdmi->regm, offset << hdmi->reg_shift, &val);
 
 	return val;
 }
@@ -334,28 +309,7 @@ static void repo_hpd_event(struct work_struct *p_work)
 	mutex_unlock(&hdmi->mutex);
 
 	if (hdmi->bridge.dev) {
-		bool change;
-
-		change = drm_helper_hpd_irq_event(hdmi->bridge.dev);
-		if (change) {
-#ifdef CONFIG_CEC_NOTIFIER
-			cec_notifier_repo_cec_hpd(hdmi->cec_notifier,
-						  hdmi->hpd_state, ktime_get());
-#endif
-			if (hdmi->hpd_state) {
-#ifdef CONFIG_CEC_NOTIFIER
-				struct edid *edid;
-				edid = dw_hdmi_get_edid(hdmi, &hdmi->connector);
-				if (!edid)
-					return;
-				drm_connector_update_edid_property(
-					&hdmi->connector, edid);
-				cec_notifier_set_phys_addr_from_edid(
-					hdmi->cec_notifier, edid);
-				kfree(edid);
-#endif
-			}
-		}
+		drm_helper_hpd_irq_event(hdmi->bridge.dev);
 	}
 
 	msleep(150);
@@ -412,15 +366,8 @@ static void dw_hdmi_i2c_set_divs(struct dw_hdmi *hdmi)
 	unsigned long div_low, div_high;
 
 	/* Standard-mode */
-	if (hdmi->i2c->scl_high_ns < 4000)
-		high_ns = 4708;
-	else
-		high_ns = hdmi->i2c->scl_high_ns;
-
-	if (hdmi->i2c->scl_low_ns < 4700)
-		low_ns = 4916;
-	else
-		low_ns = hdmi->i2c->scl_low_ns;
+	high_ns = 4708;
+	low_ns = 4916;
 
 	/* Adjust to avoid overflow */
 	clk_rate_khz = DIV_ROUND_UP(clk_get_rate(hdmi->isfr_clk), 1000);
@@ -444,12 +391,6 @@ static void dw_hdmi_i2c_set_divs(struct dw_hdmi *hdmi)
 	hdmi_writeb(hdmi, (div_high >> 8) & 0xff, HDMI_I2CM_SS_SCL_HCNT_1_ADDR);
 	hdmi_writeb(hdmi, div_low & 0xff, HDMI_I2CM_SS_SCL_LCNT_0_ADDR);
 	hdmi_writeb(hdmi, (div_low >> 8) & 0xff, HDMI_I2CM_SS_SCL_LCNT_1_ADDR);
-	if (!hdmi->eswin_plat) {
-		hdmi_writeb(hdmi, 0x13, HDMI_I2CM_SS_SCL_HCNT_0_ADDR);
-		hdmi_writeb(hdmi, 0x00, HDMI_I2CM_SS_SCL_HCNT_1_ADDR);
-		hdmi_writeb(hdmi, 0x16, HDMI_I2CM_SS_SCL_LCNT_0_ADDR);
-		hdmi_writeb(hdmi, 0x00, HDMI_I2CM_SS_SCL_LCNT_1_ADDR);
-	}
 }
 
 static void dw_hdmi_i2c_init(struct dw_hdmi *hdmi)
@@ -457,9 +398,8 @@ static void dw_hdmi_i2c_init(struct dw_hdmi *hdmi)
 	hdmi_writeb(hdmi, HDMI_PHY_I2CM_INT_ADDR_DONE_POL,
 		    HDMI_PHY_I2CM_INT_ADDR);
 
-	hdmi_writeb(hdmi,
-		    HDMI_PHY_I2CM_CTLINT_ADDR_NAC_POL |
-			    HDMI_PHY_I2CM_CTLINT_ADDR_ARBITRATION_POL,
+	hdmi_writeb(hdmi, HDMI_PHY_I2CM_CTLINT_ADDR_NAC_POL |
+		    HDMI_PHY_I2CM_CTLINT_ADDR_ARBITRATION_POL,
 		    HDMI_PHY_I2CM_CTLINT_ADDR);
 
 	/* Software reset */
@@ -483,9 +423,6 @@ static void dw_hdmi_i2c_init(struct dw_hdmi *hdmi)
 
 	/* set SDA high level holding time */
 	hdmi_writeb(hdmi, 0x48, HDMI_I2CM_SDA_HOLD);
-	if (!hdmi->eswin_plat) {
-		hdmi_writeb(hdmi, 0x0f, HDMI_I2CM_SDA_HOLD);
-	}
 	dw_hdmi_i2c_set_divs(hdmi);
 }
 
@@ -498,37 +435,37 @@ static bool dw_hdmi_i2c_unwedge(struct dw_hdmi *hdmi)
 	dev_info(hdmi->dev, "Attempting to unwedge stuck i2c bus\n");
 
 	/*
-     * This is a huge hack to workaround a problem where the dw_hdmi i2c
-     * bus could sometimes get wedged.  Once wedged there doesn't appear
-     * to be any way to unwedge it (including the HDMI_I2CM_SOFTRSTZ)
-     * other than pulsing the SDA line.
-     *
-     * We appear to be able to pulse the SDA line (in the eyes of dw_hdmi)
-     * by:
-     * 1. Remux the pin as a GPIO output, driven low.
-     * 2. Wait a little while.  1 ms seems to work, but we'll do 10.
-     * 3. Immediately jump to remux the pin as dw_hdmi i2c again.
-     *
-     * At the moment of remuxing, the line will still be low due to its
-     * recent stint as an output, but then it will be pulled high by the
-     * (presumed) external pullup.  dw_hdmi seems to see this as a rising
-     * edge and that seems to get it out of its jam.
-     *
-     * This wedging was only ever seen on one TV, and only on one of
-     * its HDMI ports.  It happened when the TV was powered on while the
-     * device was plugged in.  A scope trace shows the TV bringing both SDA
-     * and SCL low, then bringing them both back up at roughly the same
-     * time.  Presumably this confuses dw_hdmi because it saw activity but
-     * no real STOP (maybe it thinks there's another master on the bus?).
-     * Giving it a clean rising edge of SDA while SCL is already high
-     * presumably makes dw_hdmi see a STOP which seems to bring dw_hdmi out
-     * of its stupor.
-     *
-     * Note that after coming back alive, transfers seem to immediately
-     * resume, so if we unwedge due to a timeout we should wait a little
-     * longer for our transfer to finish, since it might have just started
-     * now.
-     */
+	 * This is a huge hack to workaround a problem where the dw_hdmi i2c
+	 * bus could sometimes get wedged.  Once wedged there doesn't appear
+	 * to be any way to unwedge it (including the HDMI_I2CM_SOFTRSTZ)
+	 * other than pulsing the SDA line.
+	 *
+	 * We appear to be able to pulse the SDA line (in the eyes of dw_hdmi)
+	 * by:
+	 * 1. Remux the pin as a GPIO output, driven low.
+	 * 2. Wait a little while.  1 ms seems to work, but we'll do 10.
+	 * 3. Immediately jump to remux the pin as dw_hdmi i2c again.
+	 *
+	 * At the moment of remuxing, the line will still be low due to its
+	 * recent stint as an output, but then it will be pulled high by the
+	 * (presumed) external pullup.  dw_hdmi seems to see this as a rising
+	 * edge and that seems to get it out of its jam.
+	 *
+	 * This wedging was only ever seen on one TV, and only on one of
+	 * its HDMI ports.  It happened when the TV was powered on while the
+	 * device was plugged in.  A scope trace shows the TV bringing both SDA
+	 * and SCL low, then bringing them both back up at roughly the same
+	 * time.  Presumably this confuses dw_hdmi because it saw activity but
+	 * no real STOP (maybe it thinks there's another master on the bus?).
+	 * Giving it a clean rising edge of SDA while SCL is already high
+	 * presumably makes dw_hdmi see a STOP which seems to bring dw_hdmi out
+	 * of its stupor.
+	 *
+	 * Note that after coming back alive, transfers seem to immediately
+	 * resume, so if we unwedge due to a timeout we should wait a little
+	 * longer for our transfer to finish, since it might have just started
+	 * now.
+	 */
 	pinctrl_select_state(hdmi->pinctrl, hdmi->unwedge_state);
 	msleep(10);
 	pinctrl_select_state(hdmi->pinctrl, hdmi->default_state);
@@ -560,8 +497,8 @@ static int dw_hdmi_i2c_wait(struct dw_hdmi *hdmi)
 	return 0;
 }
 
-static int dw_hdmi_i2c_read(struct dw_hdmi *hdmi, unsigned char *buf,
-			    unsigned int length)
+static int dw_hdmi_i2c_read(struct dw_hdmi *hdmi,
+			    unsigned char *buf, unsigned int length)
 {
 	struct dw_hdmi_i2c *i2c = hdmi->i2c;
 	int ret;
@@ -598,8 +535,8 @@ static int dw_hdmi_i2c_read(struct dw_hdmi *hdmi, unsigned char *buf,
 	return 0;
 }
 
-static int dw_hdmi_i2c_write(struct dw_hdmi *hdmi, unsigned char *buf,
-			     unsigned int length)
+static int dw_hdmi_i2c_write(struct dw_hdmi *hdmi,
+			     unsigned char *buf, unsigned int length)
 {
 	struct dw_hdmi_i2c *i2c = hdmi->i2c;
 	int ret;
@@ -632,8 +569,8 @@ static int dw_hdmi_i2c_write(struct dw_hdmi *hdmi, unsigned char *buf,
 	return 0;
 }
 
-static int dw_hdmi_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
-			    int num)
+static int dw_hdmi_i2c_xfer(struct i2c_adapter *adap,
+			    struct i2c_msg *msgs, int num)
 {
 	struct dw_hdmi *hdmi = i2c_get_adapdata(adap);
 	struct dw_hdmi_i2c *i2c = hdmi->i2c;
@@ -642,11 +579,11 @@ static int dw_hdmi_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 
 	if (addr == DDC_CI_ADDR)
 		/*
-         * The internal I2C controller does not support the multi-byte
-         * read and write operations needed for DDC/CI.
-         * TOFIX: Blacklist the DDC/CI address until we filter out
-         * unsupported I2C operations.
-         */
+		 * The internal I2C controller does not support the multi-byte
+		 * read and write operations needed for DDC/CI.
+		 * TOFIX: Blacklist the DDC/CI address until we filter out
+		 * unsupported I2C operations.
+		 */
 		return -EOPNOTSUPP;
 
 	dev_dbg(hdmi->dev, "xfer: num: %d, addr: %#x\n", num, addr);
@@ -654,8 +591,8 @@ static int dw_hdmi_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 	for (i = 0; i < num; i++) {
 		if (msgs[i].len == 0) {
 			dev_dbg(hdmi->dev,
-				"unsupported transfer %d/%d, no data\n", i + 1,
-				num);
+				"unsupported transfer %d/%d, no data\n",
+				i + 1, num);
 			return -EOPNOTSUPP;
 		}
 	}
@@ -771,9 +708,8 @@ static struct i2c_adapter *dw_hdmi_i2c_adapter(struct dw_hdmi *hdmi)
 	adap->class = I2C_CLASS_DDC;
 	adap->owner = THIS_MODULE;
 	adap->dev.parent = hdmi->dev;
-	adap->dev.of_node = hdmi->dev->of_node;
 	adap->algo = &dw_hdmi_algorithm;
-	strlcpy(adap->name, "DesignWare HDMI", sizeof(adap->name));
+	strscpy(adap->name, "DesignWare HDMI", sizeof(adap->name));
 	i2c_set_adapdata(adap, hdmi);
 
 	ret = i2c_add_adapter(adap);
@@ -801,9 +737,9 @@ static void hdmi_set_cts_n(struct dw_hdmi *hdmi, unsigned int cts,
 
 	/* Use automatic CTS generation mode when CTS is not set */
 	if (cts)
-		hdmi_writeb(hdmi,
-			    ((cts >> 16) & HDMI_AUD_CTS3_AUDCTS19_16_MASK) |
-				    HDMI_AUD_CTS3_CTS_MANUAL,
+		hdmi_writeb(hdmi, ((cts >> 16) &
+				   HDMI_AUD_CTS3_AUDCTS19_16_MASK) |
+				  HDMI_AUD_CTS3_CTS_MANUAL,
 			    HDMI_AUD_CTS3);
 	else
 		hdmi_writeb(hdmi, 0, HDMI_AUD_CTS3);
@@ -833,6 +769,8 @@ static unsigned int hdmi_compute_n(unsigned int freq, unsigned long pixel_clk)
 			n = 4096;
 		else if (pixel_clk == 74176000 || pixel_clk == 148352000)
 			n = 11648;
+		else if (pixel_clk == 297000000)
+			n = 3072;
 		else
 			n = 4096;
 		n *= mult;
@@ -845,6 +783,8 @@ static unsigned int hdmi_compute_n(unsigned int freq, unsigned long pixel_clk)
 			n = 17836;
 		else if (pixel_clk == 148352000)
 			n = 8918;
+		else if (pixel_clk == 297000000)
+			n = 4704;
 		else
 			n = 6272;
 		n *= mult;
@@ -859,6 +799,8 @@ static unsigned int hdmi_compute_n(unsigned int freq, unsigned long pixel_clk)
 			n = 11648;
 		else if (pixel_clk == 148352000)
 			n = 5824;
+		else if (pixel_clk == 297000000)
+			n = 5120;
 		else
 			n = 6144;
 		n *= mult;
@@ -879,20 +821,20 @@ static unsigned int hdmi_compute_n(unsigned int freq, unsigned long pixel_clk)
  * or AHB audio DMA (AHBAUDDMA) interface is active
  * (for S/PDIF interface this information comes from the stream).
  */
-void dw_hdmi_set_channel_status(struct dw_hdmi *hdmi, u8 *channel_status)
+void dw_hdmi_set_channel_status(struct dw_hdmi *hdmi,
+				u8 *channel_status)
 {
 	/*
-     * Set channel status register for frequency and word length.
-     * Use default values for other registers.
-     */
+	 * Set channel status register for frequency and word length.
+	 * Use default values for other registers.
+	 */
 	hdmi_writeb(hdmi, channel_status[3], HDMI_FC_AUDSCHNLS7);
 	hdmi_writeb(hdmi, channel_status[4], HDMI_FC_AUDSCHNLS8);
 }
 EXPORT_SYMBOL_GPL(dw_hdmi_set_channel_status);
 
 static void hdmi_set_clk_regenerator(struct dw_hdmi *hdmi,
-				     unsigned long pixel_clk,
-				     unsigned int sample_rate)
+	unsigned long pixel_clk, unsigned int sample_rate)
 {
 	unsigned long ftdms = pixel_clk;
 	unsigned int n, cts;
@@ -903,23 +845,23 @@ static void hdmi_set_clk_regenerator(struct dw_hdmi *hdmi,
 
 	config3 = hdmi_readb(hdmi, HDMI_CONFIG3_ID);
 
-	/* Only compute CTS when using internal AHB audio */
-	if (config3 & HDMI_CONFIG3_AHBAUDDMA) {
+	/* Compute CTS when using internal AHB audio or General Parallel audio*/
+	if ((config3 & HDMI_CONFIG3_AHBAUDDMA) || (config3 & HDMI_CONFIG3_GPAUD)) {
 		/*
-         * Compute the CTS value from the N value.  Note that CTS and N
-         * can be up to 20 bits in total, so we need 64-bit math.  Also
-         * note that our TDMS clock is not fully accurate; it is
-         * accurate to kHz.  This can introduce an unnecessary remainder
-         * in the calculation below, so we don't try to warn about that.
-         */
+		 * Compute the CTS value from the N value.  Note that CTS and N
+		 * can be up to 20 bits in total, so we need 64-bit math.  Also
+		 * note that our TDMS clock is not fully accurate; it is
+		 * accurate to kHz.  This can introduce an unnecessary remainder
+		 * in the calculation below, so we don't try to warn about that.
+		 */
 		tmp = (u64)ftdms * n;
 		do_div(tmp, 128 * sample_rate);
 		cts = tmp;
 
-		dev_dbg(hdmi->dev,
-			"%s: fs=%uHz ftdms=%lu.%03luMHz N=%d cts=%d\n",
-			__func__, sample_rate, ftdms / 1000000,
-			(ftdms / 1000) % 1000, n, cts);
+		dev_dbg(hdmi->dev, "%s: fs=%uHz ftdms=%lu.%03luMHz N=%d cts=%d\n",
+			__func__, sample_rate,
+			ftdms / 1000000, (ftdms / 1000) % 1000,
+			n, cts);
 	} else {
 		cts = 0;
 	}
@@ -946,6 +888,22 @@ static void hdmi_clk_regenerator_update_pixel_clock(struct dw_hdmi *hdmi)
 	mutex_unlock(&hdmi->audio_mutex);
 }
 
+void dw_hdmi_set_sample_width(struct dw_hdmi *hdmi, unsigned int width)
+{
+	mutex_lock(&hdmi->audio_mutex);
+	hdmi->sample_width = width;
+	mutex_unlock(&hdmi->audio_mutex);
+}
+EXPORT_SYMBOL_GPL(dw_hdmi_set_sample_width);
+
+void dw_hdmi_set_sample_non_pcm(struct dw_hdmi *hdmi, unsigned int non_pcm)
+{
+	mutex_lock(&hdmi->audio_mutex);
+	hdmi->sample_non_pcm = non_pcm;
+	mutex_unlock(&hdmi->audio_mutex);
+}
+EXPORT_SYMBOL_GPL(dw_hdmi_set_sample_non_pcm);
+
 void dw_hdmi_set_sample_rate(struct dw_hdmi *hdmi, unsigned int rate)
 {
 	mutex_lock(&hdmi->audio_mutex);
@@ -961,11 +919,12 @@ void dw_hdmi_set_channel_count(struct dw_hdmi *hdmi, unsigned int cnt)
 	u8 layout;
 
 	mutex_lock(&hdmi->audio_mutex);
+	hdmi->channels = cnt;
 
 	/*
-     * For >2 channel PCM audio, we need to select layout 1
-     * and set an appropriate channel map.
-     */
+	 * For >2 channel PCM audio, we need to select layout 1
+	 * and set an appropriate channel map.
+	 */
 	if (cnt > 2)
 		layout = HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_LAYOUT1;
 	else
@@ -1009,6 +968,89 @@ static u8 *hdmi_audio_get_eld(struct dw_hdmi *hdmi)
 	return hdmi->curr_conn->eld;
 }
 
+static void dw_hdmi_gp_audio_enable(struct dw_hdmi *hdmi)
+{
+	const struct dw_hdmi_plat_data *pdata = hdmi->plat_data;
+	int sample_freq = 0x2, org_sample_freq = 0xD;
+	int ch_mask = BIT(hdmi->channels) - 1;
+
+	switch (hdmi->sample_rate) {
+	case 32000:
+		sample_freq = 0x03;
+		org_sample_freq = 0x0C;
+		break;
+	case 44100:
+		sample_freq = 0x00;
+		org_sample_freq = 0x0F;
+		break;
+	case 48000:
+		sample_freq = 0x02;
+		org_sample_freq = 0x0D;
+		break;
+	case 88200:
+		sample_freq = 0x08;
+		org_sample_freq = 0x07;
+		break;
+	case 96000:
+		sample_freq = 0x0A;
+		org_sample_freq = 0x05;
+		break;
+	case 176400:
+		sample_freq = 0x0C;
+		org_sample_freq = 0x03;
+		break;
+	case 192000:
+		sample_freq = 0x0E;
+		org_sample_freq = 0x01;
+		break;
+	default:
+		break;
+	}
+
+	hdmi_set_cts_n(hdmi, hdmi->audio_cts, hdmi->audio_n);
+	hdmi_enable_audio_clk(hdmi, true);
+
+	hdmi_writeb(hdmi, 0x1, HDMI_FC_AUDSCHNLS0);
+	hdmi_writeb(hdmi, hdmi->channels, HDMI_FC_AUDSCHNLS2);
+	hdmi_writeb(hdmi, 0x22, HDMI_FC_AUDSCHNLS3);
+	hdmi_writeb(hdmi, 0x22, HDMI_FC_AUDSCHNLS4);
+	hdmi_writeb(hdmi, 0x11, HDMI_FC_AUDSCHNLS5);
+	hdmi_writeb(hdmi, 0x11, HDMI_FC_AUDSCHNLS6);
+	hdmi_writeb(hdmi, (0x3 << 4) | sample_freq, HDMI_FC_AUDSCHNLS7);
+	hdmi_writeb(hdmi, (org_sample_freq << 4) | 0xb, HDMI_FC_AUDSCHNLS8);
+
+	hdmi_writeb(hdmi, ch_mask, HDMI_GP_CONF1);
+	hdmi_writeb(hdmi, 0x02, HDMI_GP_CONF2);
+	hdmi_writeb(hdmi, 0x01, HDMI_GP_CONF0);
+
+	hdmi_modb(hdmi,  0x3, 0x3, HDMI_FC_DATAUTO3);
+
+	/* hbr */
+	if (hdmi->sample_rate == 192000 && hdmi->channels == 8 &&
+	    hdmi->sample_width == 32 && hdmi->sample_non_pcm)
+		hdmi_modb(hdmi, 0x01, 0x01, HDMI_GP_CONF2);
+
+	if (pdata->enable_audio)
+		pdata->enable_audio(hdmi,
+				    hdmi->channels,
+				    hdmi->sample_width,
+				    hdmi->sample_rate,
+				    hdmi->sample_non_pcm);
+}
+
+static void dw_hdmi_gp_audio_disable(struct dw_hdmi *hdmi)
+{
+	const struct dw_hdmi_plat_data *pdata = hdmi->plat_data;
+
+	hdmi_set_cts_n(hdmi, hdmi->audio_cts, 0);
+
+	hdmi_modb(hdmi,  0, 0x3, HDMI_FC_DATAUTO3);
+	if (pdata->disable_audio)
+		pdata->disable_audio(hdmi);
+
+	hdmi_enable_audio_clk(hdmi, false);
+}
+
 static void dw_hdmi_ahb_audio_enable(struct dw_hdmi *hdmi)
 {
 	hdmi_set_cts_n(hdmi, hdmi->audio_cts, hdmi->audio_n);
@@ -1143,9 +1185,9 @@ static int hdmi_bus_fmt_color_depth(unsigned int bus_format)
 /*
  * this submodule is responsible for the video data synchronization.
  * for example, for RGB 4:4:4 input, the data map is defined as
- *          pin{47~40} <==> R[7:0]
- *          pin{31~24} <==> G[7:0]
- *          pin{15~8}  <==> B[7:0]
+ *			pin{47~40} <==> R[7:0]
+ *			pin{31~24} <==> G[7:0]
+ *			pin{15~8}  <==> B[7:0]
  */
 static void hdmi_video_sample(struct dw_hdmi *hdmi)
 {
@@ -1198,14 +1240,14 @@ static void hdmi_video_sample(struct dw_hdmi *hdmi)
 	}
 
 	val = HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_DISABLE |
-	      ((color_format << HDMI_TX_INVID0_VIDEO_MAPPING_OFFSET) &
-	       HDMI_TX_INVID0_VIDEO_MAPPING_MASK);
+		((color_format << HDMI_TX_INVID0_VIDEO_MAPPING_OFFSET) &
+		HDMI_TX_INVID0_VIDEO_MAPPING_MASK);
 	hdmi_writeb(hdmi, val, HDMI_TX_INVID0);
 
 	/* Enable TX stuffing: When DE is inactive, fix the output data to 0 */
 	val = HDMI_TX_INSTUFFING_BDBDATA_STUFFING_ENABLE |
-	      HDMI_TX_INSTUFFING_RCRDATA_STUFFING_ENABLE |
-	      HDMI_TX_INSTUFFING_GYDATA_STUFFING_ENABLE;
+		HDMI_TX_INSTUFFING_RCRDATA_STUFFING_ENABLE |
+		HDMI_TX_INSTUFFING_GYDATA_STUFFING_ENABLE;
 	hdmi_writeb(hdmi, val, HDMI_TX_INSTUFFING);
 	hdmi_writeb(hdmi, 0x0, HDMI_TX_GYDATA0);
 	hdmi_writeb(hdmi, 0x0, HDMI_TX_GYDATA1);
@@ -1368,15 +1410,18 @@ static void hdmi_video_packetize(struct dw_hdmi *hdmi)
 	unsigned int output_select = HDMI_VP_CONF_OUTPUT_SELECTOR_PP;
 	struct hdmi_data_info *hdmi_data = &hdmi->hdmi_data;
 	u8 val, vp_conf;
+	u8 clear_gcp_auto = 0;
+
 
 	if (hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_out_bus_format) ||
 	    hdmi_bus_fmt_is_yuv444(hdmi->hdmi_data.enc_out_bus_format) ||
 	    hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format)) {
 		switch (hdmi_bus_fmt_color_depth(
-			hdmi->hdmi_data.enc_out_bus_format)) {
+					hdmi->hdmi_data.enc_out_bus_format)) {
 		case 8:
 			color_depth = 4;
 			output_select = HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS;
+			clear_gcp_auto = 1;
 			break;
 		case 10:
 			color_depth = 5;
@@ -1392,10 +1437,11 @@ static void hdmi_video_packetize(struct dw_hdmi *hdmi)
 		}
 	} else if (hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_out_bus_format)) {
 		switch (hdmi_bus_fmt_color_depth(
-			hdmi->hdmi_data.enc_out_bus_format)) {
+					hdmi->hdmi_data.enc_out_bus_format)) {
 		case 0:
 		case 8:
 			remap_size = HDMI_VP_REMAP_YCC422_16bit;
+			clear_gcp_auto = 1;
 			break;
 		case 10:
 			remap_size = HDMI_VP_REMAP_YCC422_20bit;
@@ -1414,12 +1460,25 @@ static void hdmi_video_packetize(struct dw_hdmi *hdmi)
 
 	/* set the packetizer registers */
 	val = ((color_depth << HDMI_VP_PR_CD_COLOR_DEPTH_OFFSET) &
-	       HDMI_VP_PR_CD_COLOR_DEPTH_MASK) |
-	      ((hdmi_data->pix_repet_factor
-		<< HDMI_VP_PR_CD_DESIRED_PR_FACTOR_OFFSET) &
-	       HDMI_VP_PR_CD_DESIRED_PR_FACTOR_MASK);
+		HDMI_VP_PR_CD_COLOR_DEPTH_MASK) |
+		((hdmi_data->pix_repet_factor <<
+		HDMI_VP_PR_CD_DESIRED_PR_FACTOR_OFFSET) &
+		HDMI_VP_PR_CD_DESIRED_PR_FACTOR_MASK);
 	hdmi_writeb(hdmi, val, HDMI_VP_PR_CD);
 
+	/* HDMI1.4b specification section 6.5.3:
+	 * Source shall only send GCPs with non-zero CD to sinks
+	 * that indicate support for Deep Color.
+	 * GCP only transmit CD and do not handle AVMUTE, PP norDefault_Phase (yet).
+	 * Disable Auto GCP when 24-bit color for sinks that not support Deep Color.
+	 */
+	val = hdmi_readb(hdmi, HDMI_FC_DATAUTO3);
+	if (clear_gcp_auto == 1)
+		val &= ~HDMI_FC_DATAUTO3_GCP_AUTO;
+	else
+		val |= HDMI_FC_DATAUTO3_GCP_AUTO;
+	hdmi_writeb(hdmi, val, HDMI_FC_DATAUTO3);
+
 	hdmi_modb(hdmi, HDMI_VP_STUFF_PR_STUFFING_STUFFING_MODE,
 		  HDMI_VP_STUFF_PR_STUFFING_MASK, HDMI_VP_STUFF);
 
@@ -1433,8 +1492,8 @@ static void hdmi_video_packetize(struct dw_hdmi *hdmi)
 	}
 
 	hdmi_modb(hdmi, vp_conf,
-		  HDMI_VP_CONF_PR_EN_MASK | HDMI_VP_CONF_BYPASS_SELECT_MASK,
-		  HDMI_VP_CONF);
+		  HDMI_VP_CONF_PR_EN_MASK |
+		  HDMI_VP_CONF_BYPASS_SELECT_MASK, HDMI_VP_CONF);
 
 	hdmi_modb(hdmi, 1 << HDMI_VP_STUFF_IDEFAULT_PHASE_OFFSET,
 		  HDMI_VP_STUFF_IDEFAULT_PHASE_MASK, HDMI_VP_STUFF);
@@ -1459,15 +1518,12 @@ static void hdmi_video_packetize(struct dw_hdmi *hdmi)
 
 	hdmi_modb(hdmi, vp_conf,
 		  HDMI_VP_CONF_BYPASS_EN_MASK | HDMI_VP_CONF_PP_EN_ENMASK |
-			  HDMI_VP_CONF_YCC422_EN_MASK,
-		  HDMI_VP_CONF);
+		  HDMI_VP_CONF_YCC422_EN_MASK, HDMI_VP_CONF);
 
-	hdmi_modb(hdmi,
-		  HDMI_VP_STUFF_PP_STUFFING_STUFFING_MODE |
-			  HDMI_VP_STUFF_YCC422_STUFFING_STUFFING_MODE,
+	hdmi_modb(hdmi, HDMI_VP_STUFF_PP_STUFFING_STUFFING_MODE |
+			HDMI_VP_STUFF_YCC422_STUFFING_STUFFING_MODE,
 		  HDMI_VP_STUFF_PP_STUFFING_MASK |
-			  HDMI_VP_STUFF_YCC422_STUFFING_MASK,
-		  HDMI_VP_STUFF);
+		  HDMI_VP_STUFF_YCC422_STUFFING_MASK, HDMI_VP_STUFF);
 
 	hdmi_modb(hdmi, output_select, HDMI_VP_CONF_OUTPUT_SELECTOR_MASK,
 		  HDMI_VP_CONF);
@@ -1477,34 +1533,13 @@ static void hdmi_video_packetize(struct dw_hdmi *hdmi)
  * Synopsys PHY Handling
  */
 
-static inline void hdmi_phy_test_clear(struct dw_hdmi *hdmi, unsigned char bit)
+static inline void hdmi_phy_test_clear(struct dw_hdmi *hdmi,
+				       unsigned char bit)
 {
 	hdmi_modb(hdmi, bit << HDMI_PHY_TST0_TSTCLR_OFFSET,
 		  HDMI_PHY_TST0_TSTCLR_MASK, HDMI_PHY_TST0);
 }
 
-static inline void hdmi_phy_test_enable(struct dw_hdmi *hdmi, unsigned char bit)
-{
-	hdmi_modb(hdmi, bit << HDMI_PHY_TST0_TSTEN_OFFSET,
-		  HDMI_PHY_TST0_TSTEN_MASK, HDMI_PHY_TST0);
-}
-
-static inline void hdmi_phy_test_clock(struct dw_hdmi *hdmi, unsigned char bit)
-{
-	hdmi_modb(hdmi, bit << HDMI_PHY_TST0_TSTCLK_OFFSET,
-		  HDMI_PHY_TST0_TSTCLK_MASK, HDMI_PHY_TST0);
-}
-
-static inline void hdmi_phy_test_din(struct dw_hdmi *hdmi, unsigned char bit)
-{
-	hdmi_writeb(hdmi, bit, HDMI_PHY_TST1);
-}
-
-static inline void hdmi_phy_test_dout(struct dw_hdmi *hdmi, unsigned char bit)
-{
-	hdmi_writeb(hdmi, bit, HDMI_PHY_TST2);
-}
-
 static bool hdmi_phy_wait_i2c_done(struct dw_hdmi *hdmi, int msec)
 {
 	u32 val;
@@ -1569,9 +1604,9 @@ static bool dw_hdmi_support_scdc(struct dw_hdmi *hdmi,
 		return false;
 
 	/*
-     * Disable if display only support low TMDS rates and scrambling
-     * for low rates is not supported either
-     */
+	 * Disable if display only support low TMDS rates and scrambling
+	 * for low rates is not supported either
+	 */
 	if (!display->hdmi.scdc.scrambling.low_rates &&
 	    display->max_tmds_clock <= 340000)
 		return false;
@@ -1600,9 +1635,9 @@ void dw_hdmi_set_high_tmds_clock_ratio(struct dw_hdmi *hdmi,
 	/* Control for TMDS Bit Period/TMDS Clock-Period Ratio */
 	if (dw_hdmi_support_scdc(hdmi, display)) {
 		if (mtmdsclock > HDMI14_MAX_TMDSCLK)
-			drm_scdc_set_high_tmds_clock_ratio(hdmi->ddc, 1);
+			drm_scdc_set_high_tmds_clock_ratio(hdmi->curr_conn, 1);
 		else
-			drm_scdc_set_high_tmds_clock_ratio(hdmi->ddc, 0);
+			drm_scdc_set_high_tmds_clock_ratio(hdmi->curr_conn, 0);
 	}
 }
 EXPORT_SYMBOL_GPL(dw_hdmi_set_high_tmds_clock_ratio);
@@ -1610,7 +1645,8 @@ EXPORT_SYMBOL_GPL(dw_hdmi_set_high_tmds_clock_ratio);
 static void dw_hdmi_phy_enable_powerdown(struct dw_hdmi *hdmi, bool enable)
 {
 	hdmi_mask_writeb(hdmi, !enable, HDMI_PHY_CONF0,
-			 HDMI_PHY_CONF0_PDZ_OFFSET, HDMI_PHY_CONF0_PDZ_MASK);
+			 HDMI_PHY_CONF0_PDZ_OFFSET,
+			 HDMI_PHY_CONF0_PDZ_MASK);
 }
 
 static void dw_hdmi_phy_enable_tmds(struct dw_hdmi *hdmi, u8 enable)
@@ -1657,13 +1693,21 @@ static void dw_hdmi_phy_sel_interface_control(struct dw_hdmi *hdmi, u8 enable)
 			 HDMI_PHY_CONF0_SELDIPIF_MASK);
 }
 
-void dw_hdmi_phy_reset(struct dw_hdmi *hdmi)
+void dw_hdmi_phy_gen1_reset(struct dw_hdmi *hdmi)
+{
+	/* PHY reset. The reset signal is active low on Gen1 PHYs. */
+	hdmi_writeb(hdmi, 0, HDMI_MC_PHYRSTZ);
+	hdmi_writeb(hdmi, HDMI_MC_PHYRSTZ_PHYRSTZ, HDMI_MC_PHYRSTZ);
+}
+EXPORT_SYMBOL_GPL(dw_hdmi_phy_gen1_reset);
+
+void dw_hdmi_phy_gen2_reset(struct dw_hdmi *hdmi)
 {
 	/* PHY reset. The reset signal is active high on Gen2 PHYs. */
 	hdmi_writeb(hdmi, HDMI_MC_PHYRSTZ_PHYRSTZ, HDMI_MC_PHYRSTZ);
 	hdmi_writeb(hdmi, 0, HDMI_MC_PHYRSTZ);
 }
-EXPORT_SYMBOL_GPL(dw_hdmi_phy_reset);
+EXPORT_SYMBOL_GPL(dw_hdmi_phy_gen2_reset);
 
 void dw_hdmi_phy_i2c_set_addr(struct dw_hdmi *hdmi, u8 address)
 {
@@ -1688,9 +1732,9 @@ static void dw_hdmi_phy_power_off(struct dw_hdmi *hdmi)
 	dw_hdmi_phy_gen2_txpwron(hdmi, 0);
 
 	/*
-     * Wait for TX_PHY_LOCK to be deasserted to indicate that the PHY went
-     * to low power mode.
-     */
+	 * Wait for TX_PHY_LOCK to be deasserted to indicate that the PHY went
+	 * to low power mode.
+	 */
 	for (i = 0; i < 5; ++i) {
 		val = hdmi_readb(hdmi, HDMI_PHY_STAT0);
 		if (!(val & HDMI_PHY_TX_PHY_LOCK))
@@ -1722,8 +1766,9 @@ static int dw_hdmi_phy_power_on(struct dw_hdmi *hdmi)
 		return 0;
 	}
 
-	dw_hdmi_phy_gen2_pddq(hdmi, 0);
 	dw_hdmi_phy_gen2_txpwron(hdmi, 1);
+	dw_hdmi_phy_gen2_pddq(hdmi, 0);
+
 	/* Wait for PHY PLL lock */
 	for (i = 0; i < 5; ++i) {
 		val = hdmi_readb(hdmi, HDMI_PHY_STAT0) & HDMI_PHY_TX_PHY_LOCK;
@@ -1739,7 +1784,6 @@ static int dw_hdmi_phy_power_on(struct dw_hdmi *hdmi)
 	}
 
 	dev_dbg(hdmi->dev, "PHY PLL locked %u iterations\n", i);
-
 	return 0;
 }
 
@@ -1748,10 +1792,9 @@ static int dw_hdmi_phy_power_on(struct dw_hdmi *hdmi)
  * information the DWC MHL PHY has the same register layout and is thus also
  * supported by this function.
  */
-static int
-hdmi_phy_configure_dwc_hdmi_3d_tx(struct dw_hdmi *hdmi,
-				  const struct dw_hdmi_plat_data *pdata,
-				  unsigned long mpixelclock)
+static int hdmi_phy_configure_dwc_hdmi_3d_tx(struct dw_hdmi *hdmi,
+		const struct dw_hdmi_plat_data *pdata,
+		unsigned long mpixelclock)
 {
 	const struct dw_hdmi_mpll_config *mpll_config = pdata->mpll_cfg;
 	const struct dw_hdmi_curr_ctrl *curr_ctrl = pdata->cur_ctr;
@@ -1826,15 +1869,11 @@ static int hdmi_phy_configure(struct dw_hdmi *hdmi,
 	if (phy->has_svsret)
 		dw_hdmi_phy_enable_svsret(hdmi, 1);
 
-	dw_hdmi_phy_reset(hdmi);
+	dw_hdmi_phy_gen2_reset(hdmi);
 
 	hdmi_writeb(hdmi, HDMI_MC_HEACPHY_RST_ASSERT, HDMI_MC_HEACPHY_RST);
-	if (!hdmi->eswin_plat) {
-		dw_hdmi_phy_i2c_set_addr(hdmi, 0x54);
-	} else {
-		dw_hdmi_phy_i2c_set_addr(hdmi,
-					 HDMI_PHY_I2CM_SLAVE_ADDR_PHY_GEN2);
-	}
+
+	dw_hdmi_phy_i2c_set_addr(hdmi, HDMI_PHY_I2CM_SLAVE_ADDR_PHY_GEN2);
 
 	/* Write to the PHY as configured by the platform */
 	if (pdata->configure_phy)
@@ -1878,16 +1917,16 @@ static void dw_hdmi_phy_disable(struct dw_hdmi *hdmi, void *data)
 	dw_hdmi_phy_power_off(hdmi);
 }
 
-enum drm_connector_status dw_hdmi_phy_read_hpd(struct dw_hdmi *hdmi, void *data)
+enum drm_connector_status dw_hdmi_phy_read_hpd(struct dw_hdmi *hdmi,
+					       void *data)
 {
 	return hdmi_readb(hdmi, HDMI_PHY_STAT0) & HDMI_PHY_HPD ?
-		       connector_status_connected :
-		       connector_status_disconnected;
+		connector_status_connected : connector_status_disconnected;
 }
 EXPORT_SYMBOL_GPL(dw_hdmi_phy_read_hpd);
 
-void dw_hdmi_phy_update_hpd(struct dw_hdmi *hdmi, void *data, bool force,
-			    bool disabled, bool rxsense)
+void dw_hdmi_phy_update_hpd(struct dw_hdmi *hdmi, void *data,
+			    bool force, bool disabled, bool rxsense)
 {
 	u8 old_mask = hdmi->phy_mask;
 
@@ -1904,9 +1943,9 @@ EXPORT_SYMBOL_GPL(dw_hdmi_phy_update_hpd);
 void dw_hdmi_phy_setup_hpd(struct dw_hdmi *hdmi, void *data)
 {
 	/*
-     * Configure the PHY RX SENSE and HPD interrupts polarities and clear
-     * any pending interrupt.
-     */
+	 * Configure the PHY RX SENSE and HPD interrupts polarities and clear
+	 * any pending interrupt.
+	 */
 	hdmi_writeb(hdmi, HDMI_PHY_HPD | HDMI_PHY_RX_SENSE, HDMI_PHY_POL0);
 	hdmi_writeb(hdmi, HDMI_IH_PHY_STAT0_HPD | HDMI_IH_PHY_STAT0_RX_SENSE,
 		    HDMI_IH_PHY_STAT0);
@@ -1989,11 +2028,10 @@ static void hdmi_config_AVI(struct dw_hdmi *hdmi,
 	drm_hdmi_avi_infoframe_from_display_mode(&frame, connector, mode);
 
 	if (hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_out_bus_format)) {
-		drm_hdmi_avi_infoframe_quant_range(
-			&frame, connector, mode,
-			hdmi->hdmi_data.rgb_limited_range ?
-				HDMI_QUANTIZATION_RANGE_LIMITED :
-				HDMI_QUANTIZATION_RANGE_FULL);
+		drm_hdmi_avi_infoframe_quant_range(&frame, connector, mode,
+						   hdmi->hdmi_data.rgb_limited_range ?
+						   HDMI_QUANTIZATION_RANGE_LIMITED :
+						   HDMI_QUANTIZATION_RANGE_FULL);
 	} else {
 		frame.quantization_range = HDMI_QUANTIZATION_RANGE_DEFAULT;
 		frame.ycc_quantization_range =
@@ -2013,22 +2051,20 @@ static void hdmi_config_AVI(struct dw_hdmi *hdmi,
 	if (!hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_out_bus_format)) {
 		switch (hdmi->hdmi_data.enc_out_encoding) {
 		case V4L2_YCBCR_ENC_601:
-			if (hdmi->hdmi_data.enc_in_encoding ==
-			    V4L2_YCBCR_ENC_XV601)
+			if (hdmi->hdmi_data.enc_in_encoding == V4L2_YCBCR_ENC_XV601)
 				frame.colorimetry = HDMI_COLORIMETRY_EXTENDED;
 			else
 				frame.colorimetry = HDMI_COLORIMETRY_ITU_601;
 			frame.extended_colorimetry =
-				HDMI_EXTENDED_COLORIMETRY_XV_YCC_601;
+					HDMI_EXTENDED_COLORIMETRY_XV_YCC_601;
 			break;
 		case V4L2_YCBCR_ENC_709:
-			if (hdmi->hdmi_data.enc_in_encoding ==
-			    V4L2_YCBCR_ENC_XV709)
+			if (hdmi->hdmi_data.enc_in_encoding == V4L2_YCBCR_ENC_XV709)
 				frame.colorimetry = HDMI_COLORIMETRY_EXTENDED;
 			else
 				frame.colorimetry = HDMI_COLORIMETRY_ITU_709;
 			frame.extended_colorimetry =
-				HDMI_EXTENDED_COLORIMETRY_XV_YCC_709;
+					HDMI_EXTENDED_COLORIMETRY_XV_YCC_709;
 			break;
 
 		case V4L2_YCBCR_ENC_BT2020:
@@ -2044,7 +2080,7 @@ static void hdmi_config_AVI(struct dw_hdmi *hdmi,
 		default: /* Carries no data */
 			frame.colorimetry = HDMI_COLORIMETRY_ITU_601;
 			frame.extended_colorimetry =
-				HDMI_EXTENDED_COLORIMETRY_XV_YCC_601;
+					HDMI_EXTENDED_COLORIMETRY_XV_YCC_601;
 			break;
 		}
 	} else {
@@ -2056,16 +2092,16 @@ static void hdmi_config_AVI(struct dw_hdmi *hdmi,
 	frame.scan_mode = HDMI_SCAN_MODE_NONE;
 
 	/*
-     * The Designware IP uses a different byte format from standard
-     * AVI info frames, though generally the bits are in the correct
-     * bytes.
-     */
+	 * The Designware IP uses a different byte format from standard
+	 * AVI info frames, though generally the bits are in the correct
+	 * bytes.
+	 */
 
 	/*
-     * AVI data byte 1 differences: Colorspace in bits 0,1 rather than 5,6,
-     * scan info in bits 4,5 rather than 0,1 and active aspect present in
-     * bit 6 rather than 4.
-     */
+	 * AVI data byte 1 differences: Colorspace in bits 0,1 rather than 5,6,
+	 * scan info in bits 4,5 rather than 0,1 and active aspect present in
+	 * bit 6 rather than 4.
+	 */
 	val = (frame.scan_mode & 3) << 4 | (frame.colorspace & 3);
 	if (frame.active_aspect & 15)
 		val |= HDMI_FC_AVICONF0_ACTIVE_FMT_INFO_PRESENT;
@@ -2077,12 +2113,14 @@ static void hdmi_config_AVI(struct dw_hdmi *hdmi,
 
 	/* AVI data byte 2 differences: none */
 	val = ((frame.colorimetry & 0x3) << 6) |
-	      ((frame.picture_aspect & 0x3) << 4) | (frame.active_aspect & 0xf);
+	      ((frame.picture_aspect & 0x3) << 4) |
+	      (frame.active_aspect & 0xf);
 	hdmi_writeb(hdmi, val, HDMI_FC_AVICONF1);
 
 	/* AVI data byte 3 differences: none */
 	val = ((frame.extended_colorimetry & 0x7) << 4) |
-	      ((frame.quantization_range & 0x3) << 2) | (frame.nups & 0x3);
+	      ((frame.quantization_range & 0x3) << 2) |
+	      (frame.nups & 0x3);
 	if (frame.itc)
 		val |= HDMI_FC_AVICONF2_IT_CONTENT_VALID;
 	hdmi_writeb(hdmi, val, HDMI_FC_AVICONF2);
@@ -2092,18 +2130,18 @@ static void hdmi_config_AVI(struct dw_hdmi *hdmi,
 	hdmi_writeb(hdmi, val, HDMI_FC_AVIVID);
 
 	/* AVI Data Byte 5- set up input and output pixel repetition */
-	val = (((hdmi->hdmi_data.video_mode.mpixelrepetitioninput + 1)
-		<< HDMI_FC_PRCONF_INCOMING_PR_FACTOR_OFFSET) &
-	       HDMI_FC_PRCONF_INCOMING_PR_FACTOR_MASK) |
-	      ((hdmi->hdmi_data.video_mode.mpixelrepetitionoutput
-		<< HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_OFFSET) &
-	       HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_MASK);
+	val = (((hdmi->hdmi_data.video_mode.mpixelrepetitioninput + 1) <<
+		HDMI_FC_PRCONF_INCOMING_PR_FACTOR_OFFSET) &
+		HDMI_FC_PRCONF_INCOMING_PR_FACTOR_MASK) |
+		((hdmi->hdmi_data.video_mode.mpixelrepetitionoutput <<
+		HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_OFFSET) &
+		HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_MASK);
 	hdmi_writeb(hdmi, val, HDMI_FC_PRCONF);
 
 	/*
-     * AVI data byte 5 differences: content type in 0,1 rather than 4,5,
-     * ycc range in bits 2,3 rather than 6,7
-     */
+	 * AVI data byte 5 differences: content type in 0,1 rather than 4,5,
+	 * ycc range in bits 2,3 rather than 6,7
+	 */
 	val = ((frame.ycc_quantization_range & 0x3) << 2) |
 	      (frame.content_type & 0x3);
 	hdmi_writeb(hdmi, val, HDMI_FC_AVICONF3);
@@ -2119,10 +2157,9 @@ static void hdmi_config_AVI(struct dw_hdmi *hdmi,
 	hdmi_writeb(hdmi, (frame.right_bar >> 8) & 0xff, HDMI_FC_AVISRB1);
 }
 
-static void
-hdmi_config_vendor_specific_infoframe(struct dw_hdmi *hdmi,
-				      const struct drm_connector *connector,
-				      const struct drm_display_mode *mode)
+static void hdmi_config_vendor_specific_infoframe(struct dw_hdmi *hdmi,
+						  const struct drm_connector *connector,
+						  const struct drm_display_mode *mode)
 {
 	struct hdmi_vendor_infoframe frame;
 	u8 buffer[10];
@@ -2132,11 +2169,11 @@ hdmi_config_vendor_specific_infoframe(struct dw_hdmi *hdmi,
 							  mode);
 	if (err < 0)
 		/*
-         * Going into that statement does not means vendor infoframe
-         * fails. It just informed us that vendor infoframe is not
-         * needed for the selected mode. Only 4k or stereoscopic 3D
-         * mode requires vendor infoframe. So just simply return.
-         */
+		 * Going into that statement does not means vendor infoframe
+		 * fails. It just informed us that vendor infoframe is not
+		 * needed for the selected mode. Only 4k or stereoscopic 3D
+		 * mode requires vendor infoframe. So just simply return.
+		 */
 		return;
 
 	err = hdmi_vendor_infoframe_pack(&frame, buffer, sizeof(buffer));
@@ -2146,7 +2183,7 @@ hdmi_config_vendor_specific_infoframe(struct dw_hdmi *hdmi,
 		return;
 	}
 	hdmi_mask_writeb(hdmi, 0, HDMI_FC_DATAUTO0, HDMI_FC_DATAUTO0_VSD_OFFSET,
-			 HDMI_FC_DATAUTO0_VSD_MASK);
+			HDMI_FC_DATAUTO0_VSD_MASK);
 
 	/* Set the length of HDMI vendor specific InfoFrame payload */
 	hdmi_writeb(hdmi, buffer[2], HDMI_FC_VSDSIZE);
@@ -2171,7 +2208,7 @@ hdmi_config_vendor_specific_infoframe(struct dw_hdmi *hdmi,
 
 	/* Configures the Frame Composer On RDRB mode */
 	hdmi_mask_writeb(hdmi, 1, HDMI_FC_DATAUTO0, HDMI_FC_DATAUTO0_VSD_OFFSET,
-			 HDMI_FC_DATAUTO0_VSD_MASK);
+			HDMI_FC_DATAUTO0_VSD_MASK);
 }
 
 static void hdmi_config_drm_infoframe(struct dw_hdmi *hdmi,
@@ -2220,20 +2257,15 @@ static void hdmi_av_composer(struct dw_hdmi *hdmi,
 	int hblank, vblank, h_de_hs, v_de_vs, hsync_len, vsync_len;
 	unsigned int vdisplay, hdisplay;
 
-	vmode->previous_pixelclock = vmode->mpixelclock;
 	vmode->mpixelclock = mode->clock * 1000;
-	if ((mode->flags & DRM_MODE_FLAG_3D_MASK) ==
-	    DRM_MODE_FLAG_3D_FRAME_PACKING)
-		vmode->mpixelclock *= 2;
 
 	dev_dbg(hdmi->dev, "final pixclk = %d\n", vmode->mpixelclock);
 
-	vmode->previous_tmdsclock = vmode->mtmdsclock;
 	vmode->mtmdsclock = vmode->mpixelclock;
 
 	if (!hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_out_bus_format)) {
 		switch (hdmi_bus_fmt_color_depth(
-			hdmi->hdmi_data.enc_out_bus_format)) {
+				hdmi->hdmi_data.enc_out_bus_format)) {
 		case 16:
 			vmode->mtmdsclock = vmode->mpixelclock * 2;
 			break;
@@ -2253,38 +2285,38 @@ static void hdmi_av_composer(struct dw_hdmi *hdmi,
 
 	/* Set up HDMI_FC_INVIDCONF */
 	inv_val = (hdmi->hdmi_data.hdcp_enable ||
-				   (dw_hdmi_support_scdc(hdmi, display) &&
-				    (vmode->mtmdsclock > HDMI14_MAX_TMDSCLK ||
-				     hdmi_info->scdc.scrambling.low_rates)) ?
-			   HDMI_FC_INVIDCONF_HDCP_KEEPOUT_ACTIVE :
-			   HDMI_FC_INVIDCONF_HDCP_KEEPOUT_INACTIVE);
+		   (dw_hdmi_support_scdc(hdmi, display) &&
+		    (vmode->mtmdsclock > HDMI14_MAX_TMDSCLK ||
+		     hdmi_info->scdc.scrambling.low_rates)) ?
+		HDMI_FC_INVIDCONF_HDCP_KEEPOUT_ACTIVE :
+		HDMI_FC_INVIDCONF_HDCP_KEEPOUT_INACTIVE);
 
 	inv_val |= mode->flags & DRM_MODE_FLAG_PVSYNC ?
-			   HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_HIGH :
-			   HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_LOW;
+		HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_HIGH :
+		HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_LOW;
 
 	inv_val |= mode->flags & DRM_MODE_FLAG_PHSYNC ?
-			   HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_HIGH :
-			   HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_LOW;
+		HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_HIGH :
+		HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_LOW;
 
 	inv_val |= (vmode->mdataenablepolarity ?
-			    HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_HIGH :
-			    HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_LOW);
+		HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_HIGH :
+		HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_LOW);
 
 	if (hdmi->vic == 39)
 		inv_val |= HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_HIGH;
 	else
-		inv_val |=
-			mode->flags & DRM_MODE_FLAG_INTERLACE ?
-				HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_HIGH :
-				HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_LOW;
+		inv_val |= mode->flags & DRM_MODE_FLAG_INTERLACE ?
+			HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_HIGH :
+			HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_LOW;
 
 	inv_val |= mode->flags & DRM_MODE_FLAG_INTERLACE ?
-			   HDMI_FC_INVIDCONF_IN_I_P_INTERLACED :
-			   HDMI_FC_INVIDCONF_IN_I_P_PROGRESSIVE;
+		HDMI_FC_INVIDCONF_IN_I_P_INTERLACED :
+		HDMI_FC_INVIDCONF_IN_I_P_PROGRESSIVE;
 
-	inv_val |= hdmi->sink_is_hdmi ? HDMI_FC_INVIDCONF_DVI_MODEZ_HDMI_MODE :
-					HDMI_FC_INVIDCONF_DVI_MODEZ_DVI_MODE;
+	inv_val |= hdmi->sink_is_hdmi ?
+		HDMI_FC_INVIDCONF_DVI_MODEZ_HDMI_MODE :
+		HDMI_FC_INVIDCONF_DVI_MODEZ_DVI_MODE;
 
 	hdmi_writeb(hdmi, inv_val, HDMI_FC_INVIDCONF);
 
@@ -2294,9 +2326,9 @@ static void hdmi_av_composer(struct dw_hdmi *hdmi,
 	hsync_len = mode->hsync_end - mode->hsync_start;
 
 	/*
-     * When we're setting a YCbCr420 mode, we need
-     * to adjust the horizontal timing to suit.
-     */
+	 * When we're setting a YCbCr420 mode, we need
+	 * to adjust the horizontal timing to suit.
+	 */
 	if (hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format)) {
 		hdisplay /= 2;
 		hblank /= 2;
@@ -2310,17 +2342,14 @@ static void hdmi_av_composer(struct dw_hdmi *hdmi,
 	vsync_len = mode->vsync_end - mode->vsync_start;
 
 	/*
-     * When we're setting an interlaced mode, we need
-     * to adjust the vertical timing to suit.
-     */
+	 * When we're setting an interlaced mode, we need
+	 * to adjust the vertical timing to suit.
+	 */
 	if (mode->flags & DRM_MODE_FLAG_INTERLACE) {
 		vdisplay /= 2;
 		vblank /= 2;
 		v_de_vs /= 2;
 		vsync_len /= 2;
-	} else if ((mode->flags & DRM_MODE_FLAG_3D_MASK) ==
-		   DRM_MODE_FLAG_3D_FRAME_PACKING) {
-		vdisplay += mode->vtotal;
 	}
 
 	/* Scrambling Control */
@@ -2328,29 +2357,29 @@ static void hdmi_av_composer(struct dw_hdmi *hdmi,
 		if (vmode->mtmdsclock > HDMI14_MAX_TMDSCLK ||
 		    hdmi_info->scdc.scrambling.low_rates) {
 			/*
-             * HDMI2.0 Specifies the following procedure:
-             * After the Source Device has determined that
-             * SCDC_Present is set (=1), the Source Device should
-             * write the accurate Version of the Source Device
-             * to the Source Version field in the SCDCS.
-             * Source Devices compliant shall set the
-             * Source Version = 1.
-             */
-			drm_scdc_readb(hdmi->ddc, SCDC_SINK_VERSION, &bytes);
+			 * HDMI2.0 Specifies the following procedure:
+			 * After the Source Device has determined that
+			 * SCDC_Present is set (=1), the Source Device should
+			 * write the accurate Version of the Source Device
+			 * to the Source Version field in the SCDCS.
+			 * Source Devices compliant shall set the
+			 * Source Version = 1.
+			 */
+			drm_scdc_readb(hdmi->ddc, SCDC_SINK_VERSION,
+				       &bytes);
 			drm_scdc_writeb(hdmi->ddc, SCDC_SOURCE_VERSION,
-					min_t(u8, bytes,
-					      SCDC_MIN_SOURCE_VERSION));
+				min_t(u8, bytes, SCDC_MIN_SOURCE_VERSION));
 
 			/* Enabled Scrambling in the Sink */
-			drm_scdc_set_scrambling(hdmi->ddc, 1);
+			drm_scdc_set_scrambling(hdmi->curr_conn, 1);
 
 			/*
-             * To activate the scrambler feature, you must ensure
-             * that the quasi-static configuration bit
-             * fc_invidconf.HDCP_keepout is set at configuration
-             * time, before the required mc_swrstzreq.tmdsswrst_req
-             * reset request is issued.
-             */
+			 * To activate the scrambler feature, you must ensure
+			 * that the quasi-static configuration bit
+			 * fc_invidconf.HDCP_keepout is set at configuration
+			 * time, before the required mc_swrstzreq.tmdsswrst_req
+			 * reset request is issued.
+			 */
 			hdmi_writeb(hdmi, (u8)~HDMI_MC_SWRSTZ_TMDSSWRST_REQ,
 				    HDMI_MC_SWRSTZ);
 			hdmi_writeb(hdmi, 1, HDMI_FC_SCRAMBLER_CTRL);
@@ -2358,7 +2387,7 @@ static void hdmi_av_composer(struct dw_hdmi *hdmi,
 			hdmi_writeb(hdmi, 0, HDMI_FC_SCRAMBLER_CTRL);
 			hdmi_writeb(hdmi, (u8)~HDMI_MC_SWRSTZ_TMDSSWRST_REQ,
 				    HDMI_MC_SWRSTZ);
-			drm_scdc_set_scrambling(hdmi->ddc, 0);
+			drm_scdc_set_scrambling(hdmi->curr_conn, 0);
 		}
 	} else {
 		hdmi_writeb(hdmi, 0, HDMI_FC_SCRAMBLER_CTRL);
@@ -2408,10 +2437,11 @@ static void dw_hdmi_enable_video_path(struct dw_hdmi *hdmi)
 	hdmi_writeb(hdmi, 0x21, HDMI_FC_CH2PREAM);
 
 	/* Enable pixel clock and tmds data path */
-	hdmi->mc_clkdis |=
-		HDMI_MC_CLKDIS_HDCPCLK_DISABLE | HDMI_MC_CLKDIS_CSCCLK_DISABLE |
-		HDMI_MC_CLKDIS_AUDCLK_DISABLE | HDMI_MC_CLKDIS_PREPCLK_DISABLE |
-		HDMI_MC_CLKDIS_TMDSCLK_DISABLE;
+	hdmi->mc_clkdis |= HDMI_MC_CLKDIS_HDCPCLK_DISABLE |
+			   HDMI_MC_CLKDIS_CSCCLK_DISABLE |
+			   HDMI_MC_CLKDIS_AUDCLK_DISABLE |
+			   HDMI_MC_CLKDIS_PREPCLK_DISABLE |
+			   HDMI_MC_CLKDIS_TMDSCLK_DISABLE;
 	hdmi->mc_clkdis &= ~HDMI_MC_CLKDIS_PIXELCLK_DISABLE;
 	hdmi_writeb(hdmi, hdmi->mc_clkdis, HDMI_MC_CLKDIS);
 
@@ -2442,37 +2472,27 @@ static void dw_hdmi_clear_overflow(struct dw_hdmi *hdmi)
 	u8 val;
 
 	/*
-     * Under some circumstances the Frame Composer arithmetic unit can miss
-     * an FC register write due to being busy processing the previous one.
-     * The issue can be worked around by issuing a TMDS software reset and
-     * then write one of the FC registers several times.
-     *
-     * The number of iterations matters and depends on the HDMI TX revision
-     * (and possibly on the platform). So far i.MX6Q (v1.30a), i.MX6DL
-     * (v1.31a) and multiple Allwinner SoCs (v1.32a) have been identified
-     * as needing the workaround, with 4 iterations for v1.30a and 1
-     * iteration for others.
-     * The Amlogic Meson GX SoCs (v2.01a) have been identified as needing
-     * the workaround with a single iteration.
-     * The ESWIN SOC WIN2030(v2.14a) have been identified as needing the
-     * workaround with a single iteration.
-     */
+	 * Under some circumstances the Frame Composer arithmetic unit can miss
+	 * an FC register write due to being busy processing the previous one.
+	 * The issue can be worked around by issuing a TMDS software reset and
+	 * then write one of the FC registers several times.
+	 *
+	 * The number of iterations matters and depends on the HDMI TX revision
+	 * (and possibly on the platform).
+	 * 4 iterations for i.MX6Q(v1.30a) and 1 iteration for others.
+	 * i.MX6DL (v1.31a), Allwinner SoCs (v1.32a), Rockchip RK3288 SoC (v2.00a),
+	 * Amlogic Meson GX SoCs (v2.01a), RK3328/RK3399 SoCs (v2.11a)
+	 * and i.MX8MPlus (v2.13a) have been identified as needing the workaround
+	 * with a single iteration.
+	 */
 
 	switch (hdmi->version) {
 	case 0x130a:
 		count = 4;
 		break;
-	case 0x131a:
-	case 0x132a:
-	case 0x200a:
-	case 0x201a:
-	case 0x211a:
-	case 0x212a:
-	case 0x214a:
+	default:
 		count = 1;
 		break;
-	default:
-		return;
 	}
 
 	/* TMDS software reset */
@@ -2481,23 +2501,6 @@ static void dw_hdmi_clear_overflow(struct dw_hdmi *hdmi)
 	val = hdmi_readb(hdmi, HDMI_FC_INVIDCONF);
 	for (i = 0; i < count; i++)
 		hdmi_writeb(hdmi, val, HDMI_FC_INVIDCONF);
-	if (!hdmi->eswin_plat) {
-		val = hdmi_readb(hdmi, HDMI_FC_VSYNCINWIDTH);
-		for (i = 0; i < count; i++)
-			hdmi_writeb(hdmi, val, HDMI_FC_VSYNCINWIDTH);
-	}
-	/* Audio software reset */
-	if (hdmi->sink_has_audio) {
-		val = hdmi_readb(hdmi, HDMI_AUD_CONF0);
-		val &= HDMI_AUD_CONF0_I2S_SELECT_MASK;
-		hdmi_modb(hdmi, ~val, HDMI_AUD_CONF0_I2S_SELECT_MASK,
-			  HDMI_AUD_CONF0);
-		udelay(10);
-		hdmi_modb(hdmi, val | HDMI_AUD_CONF0_SW_RESET,
-			  HDMI_AUD_CONF0_SW_RESET |
-				  HDMI_AUD_CONF0_I2S_SELECT_MASK,
-			  HDMI_AUD_CONF0);
-	}
 }
 
 static void hdmi_disable_overflow_interrupts(struct dw_hdmi *hdmi)
@@ -2566,9 +2569,9 @@ static int dw_hdmi_setup(struct dw_hdmi *hdmi,
 	else
 		hdmi->hdmi_data.enc_out_bus_format = MEDIA_BUS_FMT_RGB888_1X24;
 
-	hdmi->hdmi_data.rgb_limited_range =
-		hdmi->sink_is_hdmi && drm_default_rgb_quant_range(mode) ==
-					      HDMI_QUANTIZATION_RANGE_LIMITED;
+	hdmi->hdmi_data.rgb_limited_range = hdmi->sink_is_hdmi &&
+		drm_default_rgb_quant_range(mode) ==
+		HDMI_QUANTIZATION_RANGE_LIMITED;
 
 	hdmi->hdmi_data.pix_repet_factor = 0;
 	hdmi->hdmi_data.hdcp_enable = 0;
@@ -2576,6 +2579,7 @@ static int dw_hdmi_setup(struct dw_hdmi *hdmi,
 
 	/* HDMI Initialization Step B.1 */
 	hdmi_av_composer(hdmi, &connector->display_info, mode);
+
 	/* HDMI Initializateion Step B.2 */
 	ret = hdmi->phy.ops->init(hdmi, hdmi->phy.data,
 				  &connector->display_info,
@@ -2583,6 +2587,7 @@ static int dw_hdmi_setup(struct dw_hdmi *hdmi,
 	if (ret)
 		return ret;
 	hdmi->phy.enabled = true;
+
 	/* HDMI Initialization Step B.3 */
 	dw_hdmi_enable_video_path(hdmi);
 
@@ -2605,6 +2610,7 @@ static int dw_hdmi_setup(struct dw_hdmi *hdmi,
 	} else {
 		dev_dbg(hdmi->dev, "%s DVI mode\n", __func__);
 	}
+
 	hdmi_video_packetize(hdmi);
 	hdmi_video_csc(hdmi);
 	hdmi_video_sample(hdmi);
@@ -2619,13 +2625,14 @@ static int dw_hdmi_setup(struct dw_hdmi *hdmi,
 static void initialize_hdmi_ih_mutes(struct dw_hdmi *hdmi)
 {
 	u8 ih_mute;
+
 	/*
-     * Boot up defaults are:
-     * HDMI_IH_MUTE   = 0x03 (disabled)
-     * HDMI_IH_MUTE_* = 0x00 (enabled)
-     *
-     * Disable top level interrupt bits in HDMI block
-     */
+	 * Boot up defaults are:
+	 * HDMI_IH_MUTE   = 0x03 (disabled)
+	 * HDMI_IH_MUTE_* = 0x00 (enabled)
+	 *
+	 * Disable top level interrupt bits in HDMI block
+	 */
 	ih_mute = hdmi_readb(hdmi, HDMI_IH_MUTE) |
 		  HDMI_IH_MUTE_MUTE_WAKEUP_INTERRUPT |
 		  HDMI_IH_MUTE_MUTE_ALL_INTERRUPT;
@@ -2669,10 +2676,11 @@ static void initialize_hdmi_ih_mutes(struct dw_hdmi *hdmi)
 static void dw_hdmi_poweron(struct dw_hdmi *hdmi)
 {
 	hdmi->bridge_is_on = true;
+
 	/*
-     * The curr_conn field is guaranteed to be valid here, as this function
-     * is only be called when !hdmi->disabled.
-     */
+	 * The curr_conn field is guaranteed to be valid here, as this function
+	 * is only be called when !hdmi->disabled.
+	 */
 	dev_dbg(hdmi->dev, "%s", __func__);
 	dw_hdmi_setup(hdmi, hdmi->curr_conn, &hdmi->previous_mode);
 }
@@ -2684,6 +2692,7 @@ static void dw_hdmi_poweroff(struct dw_hdmi *hdmi)
 		hdmi->phy.ops->disable(hdmi, hdmi->phy.data);
 		hdmi->phy.enabled = false;
 	}
+
 	hdmi->bridge_is_on = false;
 }
 
@@ -2727,23 +2736,17 @@ static void dw_hdmi_update_power(struct dw_hdmi *hdmi)
 static void dw_hdmi_update_phy_mask(struct dw_hdmi *hdmi)
 {
 	if (hdmi->phy.ops->update_hpd)
-		hdmi->phy.ops->update_hpd(hdmi, hdmi->phy.data, hdmi->force,
-					  hdmi->disabled, hdmi->rxsense);
+		hdmi->phy.ops->update_hpd(hdmi, hdmi->phy.data,
+					  hdmi->force, hdmi->disabled,
+					  hdmi->rxsense);
 }
 
 static enum drm_connector_status dw_hdmi_detect(struct dw_hdmi *hdmi)
 {
 	enum drm_connector_status result;
-	result = hdmi->phy.ops->read_hpd(hdmi, hdmi->phy.data);
 
-	mutex_lock(&hdmi->mutex);
-	if (result != hdmi->last_connector_result) {
-		dev_info(hdmi->dev, "read_hpd result: %d", result);
-		handle_plugged_change(hdmi,
-				      result == connector_status_connected);
-		hdmi->last_connector_result = result;
-	}
-	mutex_unlock(&hdmi->mutex);
+	result = hdmi->phy.ops->read_hpd(hdmi, hdmi->phy.data);
+	hdmi->last_connector_result = result;
 
 	return result;
 }
@@ -2778,15 +2781,15 @@ static struct edid *dw_hdmi_get_edid(struct dw_hdmi *hdmi,
 static enum drm_connector_status
 dw_hdmi_connector_detect(struct drm_connector *connector, bool force)
 {
-	struct dw_hdmi *hdmi =
-		container_of(connector, struct dw_hdmi, connector);
+	struct dw_hdmi *hdmi = container_of(connector, struct dw_hdmi,
+					     connector);
 	return dw_hdmi_detect(hdmi);
 }
 
 static int dw_hdmi_connector_get_modes(struct drm_connector *connector)
 {
-	struct dw_hdmi *hdmi =
-		container_of(connector, struct dw_hdmi, connector);
+	struct dw_hdmi *hdmi = container_of(connector, struct dw_hdmi,
+					     connector);
 	struct edid *edid;
 	int ret;
 
@@ -2828,8 +2831,8 @@ static int dw_hdmi_connector_atomic_check(struct drm_connector *connector,
 
 static void dw_hdmi_connector_force(struct drm_connector *connector)
 {
-	struct dw_hdmi *hdmi =
-		container_of(connector, struct dw_hdmi, connector);
+	struct dw_hdmi *hdmi = container_of(connector, struct dw_hdmi,
+					     connector);
 
 	mutex_lock(&hdmi->mutex);
 	hdmi->force = connector->force;
@@ -2903,7 +2906,7 @@ static void dw_hdmi_attatch_properties(struct dw_hdmi *hdmi)
 
 	enum drm_connector_status connect_status =
 		hdmi->phy.ops->read_hpd(hdmi, hdmi->phy.data);
-	const struct dw_hdmi_property_ops *ops = hdmi->plat_data->property_ops;
+		const struct dw_hdmi_property_ops *ops = hdmi->plat_data->property_ops;
 
 	if (connect_status == connector_status_connected) {
 		video_mapping = (hdmi_readb(hdmi, HDMI_TX_INVID0) &
@@ -2993,12 +2996,13 @@ static int dw_hdmi_connector_create(struct dw_hdmi *hdmi)
 
 	drm_connector_init_with_ddc(hdmi->bridge.dev, connector,
 				    &dw_hdmi_connector_funcs,
-				    DRM_MODE_CONNECTOR_HDMIA, hdmi->ddc);
+				    DRM_MODE_CONNECTOR_HDMIA,
+				    hdmi->ddc);
 
 	/*
-     * drm_connector_attach_max_bpc_property() requires the
-     * connector to have a state.
-     */
+	 * drm_connector_attach_max_bpc_property() requires the
+	 * connector to have a state.
+	 */
 	drm_atomic_helper_connector_reset(connector);
 
 	drm_connector_attach_max_bpc_property(connector, 8, 16);
@@ -3047,19 +3051,20 @@ static int dw_hdmi_connector_create(struct dw_hdmi *hdmi)
  */
 
 /* Can return a maximum of 11 possible output formats for a mode/connector */
-#define MAX_OUTPUT_SEL_FORMATS 11
+#define MAX_OUTPUT_SEL_FORMATS	11
 
-static u32 *dw_hdmi_bridge_atomic_get_output_bus_fmts(
-	struct drm_bridge *bridge, struct drm_bridge_state *bridge_state,
-	struct drm_crtc_state *crtc_state,
-	struct drm_connector_state *conn_state, unsigned int *num_output_fmts)
+static u32 *dw_hdmi_bridge_atomic_get_output_bus_fmts(struct drm_bridge *bridge,
+					struct drm_bridge_state *bridge_state,
+					struct drm_crtc_state *crtc_state,
+					struct drm_connector_state *conn_state,
+					unsigned int *num_output_fmts)
 {
 	struct drm_connector *conn = conn_state->connector;
 	struct drm_display_info *info = &conn->display_info;
 	struct drm_display_mode *mode = &crtc_state->mode;
 	u8 max_bpc = conn_state->max_requested_bpc;
 	bool is_hdmi2_sink = info->hdmi.scdc.supported ||
-			     (info->color_formats & DRM_COLOR_FORMAT_YCRCB420);
+			     (info->color_formats & DRM_COLOR_FORMAT_YCBCR420);
 	u32 *output_fmts;
 	unsigned int i = 0;
 
@@ -3070,8 +3075,9 @@ static u32 *dw_hdmi_bridge_atomic_get_output_bus_fmts(
 	if (!output_fmts)
 		return NULL;
 
-	/* If dw-hdmi is the only bridge, avoid negociating with ourselves */
-	if (list_is_singular(&bridge->encoder->bridge_chain)) {
+	/* If dw-hdmi is the first or only bridge, avoid negociating with ourselves */
+	if (list_is_singular(&bridge->encoder->bridge_chain) ||
+	    list_is_first(&bridge->chain_node, &bridge->encoder->bridge_chain)) {
 		*num_output_fmts = 1;
 		output_fmts[0] = MEDIA_BUS_FMT_FIXED;
 
@@ -3079,12 +3085,13 @@ static u32 *dw_hdmi_bridge_atomic_get_output_bus_fmts(
 	}
 
 	/*
-     * If the current mode enforces 4:2:0, force the output but format
-     * to 4:2:0 and do not add the YUV422/444/RGB formats
-     */
+	 * If the current mode enforces 4:2:0, force the output but format
+	 * to 4:2:0 and do not add the YUV422/444/RGB formats
+	 */
 	if (conn->ycbcr_420_allowed &&
 	    (drm_mode_is_420_only(info, mode) ||
 	     (is_hdmi2_sink && drm_mode_is_420_also(info, mode)))) {
+
 		/* Order bus formats from 16bit to 8bit if supported */
 		if (max_bpc >= 16 && info->bpc == 16 &&
 		    (info->hdmi.y420_dc_modes & DRM_EDID_YCBCR420_DC_48))
@@ -3101,52 +3108,53 @@ static u32 *dw_hdmi_bridge_atomic_get_output_bus_fmts(
 		/* Default 8bit fallback */
 		output_fmts[i++] = MEDIA_BUS_FMT_UYYVYY8_0_5X24;
 
-		*num_output_fmts = i;
-
-		return output_fmts;
+		if (drm_mode_is_420_only(info, mode)) {
+			*num_output_fmts = i;
+			return output_fmts;
+		}
 	}
 
 	/*
-     * Order bus formats from 16bit to 8bit and from YUV422 to RGB
-     * if supported. In any case the default RGB888 format is added
-     */
+	 * Order bus formats from 16bit to 8bit and from YUV422 to RGB
+	 * if supported. In any case the default RGB888 format is added
+	 */
+
+	/* Default 8bit RGB fallback */
+	output_fmts[i++] = MEDIA_BUS_FMT_RGB888_1X24;
 
 	if (max_bpc >= 16 && info->bpc == 16) {
-		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB444)
+		if (info->color_formats & DRM_COLOR_FORMAT_YCBCR444)
 			output_fmts[i++] = MEDIA_BUS_FMT_YUV16_1X48;
 
 		output_fmts[i++] = MEDIA_BUS_FMT_RGB161616_1X48;
 	}
 
 	if (max_bpc >= 12 && info->bpc >= 12) {
-		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB422)
+		if (info->color_formats & DRM_COLOR_FORMAT_YCBCR422)
 			output_fmts[i++] = MEDIA_BUS_FMT_UYVY12_1X24;
 
-		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB444)
+		if (info->color_formats & DRM_COLOR_FORMAT_YCBCR444)
 			output_fmts[i++] = MEDIA_BUS_FMT_YUV12_1X36;
 
 		output_fmts[i++] = MEDIA_BUS_FMT_RGB121212_1X36;
 	}
 
 	if (max_bpc >= 10 && info->bpc >= 10) {
-		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB422)
+		if (info->color_formats & DRM_COLOR_FORMAT_YCBCR422)
 			output_fmts[i++] = MEDIA_BUS_FMT_UYVY10_1X20;
 
-		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB444)
+		if (info->color_formats & DRM_COLOR_FORMAT_YCBCR444)
 			output_fmts[i++] = MEDIA_BUS_FMT_YUV10_1X30;
 
 		output_fmts[i++] = MEDIA_BUS_FMT_RGB101010_1X30;
 	}
 
-	if (info->color_formats & DRM_COLOR_FORMAT_YCRCB422)
+	if (info->color_formats & DRM_COLOR_FORMAT_YCBCR422)
 		output_fmts[i++] = MEDIA_BUS_FMT_UYVY8_1X16;
 
-	if (info->color_formats & DRM_COLOR_FORMAT_YCRCB444)
+	if (info->color_formats & DRM_COLOR_FORMAT_YCBCR444)
 		output_fmts[i++] = MEDIA_BUS_FMT_YUV8_1X24;
 
-	/* Default 8bit RGB fallback */
-	output_fmts[i++] = MEDIA_BUS_FMT_RGB888_1X24;
-
 	*num_output_fmts = i;
 
 	return output_fmts;
@@ -3172,21 +3180,22 @@ static u32 *dw_hdmi_bridge_atomic_get_output_bus_fmts(
  */
 
 /* Can return a maximum of 3 possible input formats for an output format */
-#define MAX_INPUT_SEL_FORMATS 3
+#define MAX_INPUT_SEL_FORMATS	3
 
-static u32 *dw_hdmi_bridge_atomic_get_input_bus_fmts(
-	struct drm_bridge *bridge, struct drm_bridge_state *bridge_state,
-	struct drm_crtc_state *crtc_state,
-	struct drm_connector_state *conn_state, u32 output_fmt,
-	unsigned int *num_input_fmts)
+static u32 *dw_hdmi_bridge_atomic_get_input_bus_fmts(struct drm_bridge *bridge,
+					struct drm_bridge_state *bridge_state,
+					struct drm_crtc_state *crtc_state,
+					struct drm_connector_state *conn_state,
+					u32 output_fmt,
+					unsigned int *num_input_fmts)
 {
 	u32 *input_fmts;
 	unsigned int i = 0;
 
 	*num_input_fmts = 0;
 
-	input_fmts =
-		kcalloc(MAX_INPUT_SEL_FORMATS, sizeof(*input_fmts), GFP_KERNEL);
+	input_fmts = kcalloc(MAX_INPUT_SEL_FORMATS, sizeof(*input_fmts),
+			     GFP_KERNEL);
 	if (!input_fmts)
 		return NULL;
 
@@ -3283,9 +3292,10 @@ static int dw_hdmi_bridge_atomic_check(struct drm_bridge *bridge,
 	struct dw_hdmi *hdmi = bridge->driver_private;
 
 	hdmi->hdmi_data.enc_out_bus_format =
-		bridge_state->output_bus_cfg.format;
+			bridge_state->output_bus_cfg.format;
 
-	hdmi->hdmi_data.enc_in_bus_format = bridge_state->input_bus_cfg.format;
+	hdmi->hdmi_data.enc_in_bus_format =
+			bridge_state->input_bus_cfg.format;
 
 	dev_dbg(hdmi->dev, "input format 0x%04x, output format 0x%04x\n",
 		bridge_state->input_bus_cfg.format,
@@ -3340,8 +3350,8 @@ dw_hdmi_bridge_mode_valid(struct drm_bridge *bridge,
 	}
 
 	if (pdata->mode_valid)
-		mode_status =
-			pdata->mode_valid(hdmi, pdata->priv_data, info, mode);
+		mode_status = pdata->mode_valid(hdmi, pdata->priv_data, info,
+						mode);
 
 	return mode_status;
 }
@@ -3355,7 +3365,7 @@ static void dw_hdmi_bridge_mode_set(struct drm_bridge *bridge,
 	mutex_lock(&hdmi->mutex);
 
 	/* Store the display mode for plugin/DKMS poweron events */
-	memcpy(&hdmi->previous_mode, mode, sizeof(hdmi->previous_mode));
+	drm_mode_copy(&hdmi->previous_mode, mode);
 
 	mutex_unlock(&hdmi->mutex);
 }
@@ -3370,6 +3380,7 @@ static void dw_hdmi_bridge_atomic_disable(struct drm_bridge *bridge,
 	hdmi->curr_conn = NULL;
 	dw_hdmi_update_power(hdmi);
 	dw_hdmi_update_phy_mask(hdmi);
+	handle_plugged_change(hdmi, false);
 	mutex_unlock(&hdmi->mutex);
 }
 
@@ -3388,11 +3399,11 @@ static void dw_hdmi_bridge_atomic_enable(struct drm_bridge *bridge,
 	hdmi->curr_conn = connector;
 	dw_hdmi_update_power(hdmi);
 	dw_hdmi_update_phy_mask(hdmi);
+	handle_plugged_change(hdmi, true);
 	mutex_unlock(&hdmi->mutex);
 }
 
-static enum drm_connector_status
-dw_hdmi_bridge_detect(struct drm_bridge *bridge)
+static enum drm_connector_status dw_hdmi_bridge_detect(struct drm_bridge *bridge)
 {
 	struct dw_hdmi *hdmi = bridge->driver_private;
 
@@ -3480,18 +3491,18 @@ void dw_hdmi_setup_rx_sense(struct dw_hdmi *hdmi, bool hpd, bool rx_sense)
 
 	if (!hdmi->force) {
 		/*
-         * If the RX sense status indicates we're disconnected,
-         * clear the software rxsense status.
-         */
+		 * If the RX sense status indicates we're disconnected,
+		 * clear the software rxsense status.
+		 */
 		if (!rx_sense)
 			hdmi->rxsense = false;
 
 		/*
-         * Only set the software rxsense status when both
-         * rxsense and hpd indicates we're connected.
-         * This avoids what seems to be bad behaviour in
-         * at least iMX6S versions of the phy.
-         */
+		 * Only set the software rxsense status when both
+		 * rxsense and hpd indicates we're connected.
+		 * This avoids what seems to be bad behaviour in
+		 * at least iMX6S versions of the phy.
+		 */
 		if (hpd)
 			hdmi->rxsense = true;
 
@@ -3527,8 +3538,7 @@ static irqreturn_t dw_hdmi_irq(int irq, void *dev_id)
 			phy_pol_mask |= HDMI_PHY_RX_SENSE3;
 
 		if (phy_pol_mask)
-			hdmi_modb(hdmi, ~phy_int_pol, phy_pol_mask,
-				  HDMI_PHY_POL0);
+			hdmi_modb(hdmi, ~phy_int_pol, phy_pol_mask, HDMI_PHY_POL0);
 		if (phy_int_pol & HDMI_PHY_HPD)
 			hdmi_writeb(hdmi, HDMI_I2CM_OPERATION_BUSCLEAR,
 				    HDMI_I2CM_OPERATION);
@@ -3543,14 +3553,13 @@ static irqreturn_t dw_hdmi_irq(int irq, void *dev_id)
 		if (intr_stat &
 		    (HDMI_IH_PHY_STAT0_RX_SENSE | HDMI_IH_PHY_STAT0_HPD)) {
 			hpd_flag = true;
-			dw_hdmi_setup_rx_sense(hdmi, phy_stat & HDMI_PHY_HPD,
-					       phy_stat & HDMI_PHY_RX_SENSE);
+			dw_hdmi_setup_rx_sense(hdmi,
+							phy_stat & HDMI_PHY_HPD,
+					        phy_stat & HDMI_PHY_RX_SENSE);
 
-			if ((phy_stat & (HDMI_PHY_RX_SENSE | HDMI_PHY_HPD)) ==
-			    0) {
+			if ((phy_stat & (HDMI_PHY_RX_SENSE | HDMI_PHY_HPD)) == 0) {
 				mutex_lock(&hdmi->cec_notifier_mutex);
-				cec_notifier_phys_addr_invalidate(
-					hdmi->cec_notifier);
+				cec_notifier_phys_addr_invalidate(hdmi->cec_notifier);
 				mutex_unlock(&hdmi->cec_notifier_mutex);
 			}
 		}
@@ -3581,41 +3590,35 @@ static const struct dw_hdmi_phy_data dw_hdmi_phys[] = {
 		.type = DW_HDMI_PHY_DWC_HDMI_TX_PHY,
 		.name = "DWC HDMI TX PHY",
 		.gen = 1,
-	},
-	{
+	}, {
 		.type = DW_HDMI_PHY_DWC_MHL_PHY_HEAC,
 		.name = "DWC MHL PHY + HEAC PHY",
 		.gen = 2,
 		.has_svsret = true,
 		.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,
-	},
-	{
+	}, {
 		.type = DW_HDMI_PHY_DWC_MHL_PHY,
 		.name = "DWC MHL PHY",
 		.gen = 2,
 		.has_svsret = true,
 		.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,
-	},
-	{
+	}, {
 		.type = DW_HDMI_PHY_DWC_HDMI_3D_TX_PHY_HEAC,
 		.name = "DWC HDMI 3D TX PHY + HEAC PHY",
 		.gen = 2,
 		.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,
-	},
-	{
+	}, {
 		.type = DW_HDMI_PHY_DWC_HDMI_3D_TX_PHY,
 		.name = "DWC HDMI 3D TX PHY",
 		.gen = 2,
 		.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,
-	},
-	{
+	}, {
 		.type = DW_HDMI_PHY_DWC_HDMI20_TX_PHY,
 		.name = "DWC HDMI 2.0 TX PHY",
 		.gen = 2,
 		.has_svsret = true,
 		.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,
-	},
-	{
+	}, {
 		.type = DW_HDMI_PHY_VENDOR_PHY,
 		.name = "Vendor PHY",
 	}
@@ -3625,28 +3628,25 @@ static int dw_hdmi_detect_phy(struct dw_hdmi *hdmi)
 {
 	unsigned int i;
 	u8 phy_type;
-	if (hdmi->eswin_plat) {
-		phy_type = hdmi->plat_data->phy_force_vendor ?
-				   DW_HDMI_PHY_VENDOR_PHY :
-				   hdmi_readb(hdmi, HDMI_CONFIG2_ID);
-
-		if (phy_type == DW_HDMI_PHY_VENDOR_PHY) {
-			/* Vendor PHYs require support from the glue layer. */
-			if (!hdmi->plat_data->phy_ops ||
-			    !hdmi->plat_data->phy_name) {
-				dev_err(hdmi->dev,
-					"Vendor HDMI PHY not supported by glue layer\n");
-				return -ENODEV;
-			}
 
-			hdmi->phy.ops = hdmi->plat_data->phy_ops;
-			hdmi->phy.data = hdmi->plat_data->phy_data;
-			hdmi->phy.name = hdmi->plat_data->phy_name;
-			return 0;
+	phy_type = hdmi->plat_data->phy_force_vendor ?
+				DW_HDMI_PHY_VENDOR_PHY :
+				hdmi_readb(hdmi, HDMI_CONFIG2_ID);
+
+	if (phy_type == DW_HDMI_PHY_VENDOR_PHY) {
+		/* Vendor PHYs require support from the glue layer. */
+		if (!hdmi->plat_data->phy_ops || !hdmi->plat_data->phy_name) {
+			dev_err(hdmi->dev,
+				"Vendor HDMI PHY not supported by glue layer\n");
+			return -ENODEV;
 		}
-	} else {
-		phy_type = 0xf3;
+
+		hdmi->phy.ops = hdmi->plat_data->phy_ops;
+		hdmi->phy.data = hdmi->plat_data->phy_data;
+		hdmi->phy.name = hdmi->plat_data->phy_name;
+		return 0;
 	}
+
 	/* Synopsys PHYs are handled internally. */
 	for (i = 0; i < ARRAY_SIZE(dw_hdmi_phys); ++i) {
 		if (dw_hdmi_phys[i].type == phy_type) {
@@ -3656,8 +3656,7 @@ static int dw_hdmi_detect_phy(struct dw_hdmi *hdmi)
 
 			if (!dw_hdmi_phys[i].configure &&
 			    !hdmi->plat_data->configure_phy) {
-				dev_err(hdmi->dev,
-					"%s requires platform support\n",
+				dev_err(hdmi->dev, "%s requires platform support\n",
 					hdmi->phy.name);
 				return -ENODEV;
 			}
@@ -3850,7 +3849,7 @@ static const struct dw_hdmi_reg_table hdmi_reg_table[] = {
 	{ 0x7800, 0x7818 },
 	{ 0x7900, 0x790e },
 	{ HDMI_CEC_CTRL, HDMI_CEC_WKUPCTRL },
-	{ HDMI_I2CM_SLAVE, HDMI_I2CM_MAX_REG },
+	{ HDMI_I2CM_SLAVE, HDMI_I2CM_SDA_HOLD },
 };
 
 static int dw_hdmi_ctrl_show(struct seq_file *s, void *v)
@@ -3893,7 +3892,7 @@ static ssize_t dw_hdmi_ctrl_write(struct file *file, const char __user *buf,
 		return -EFAULT;
 	if (sscanf(kbuf, "%x%x", &reg, &val) == -1)
 		return -EFAULT;
-	if ((reg < 0) || (reg > HDMI_I2CM_SCDC_READ_UPDATE_ON)) {
+	if ((reg < 0) || (reg > HDMI_I2CM_FS_SCL_LCNT_0_ADDR)) {
 		dev_err(hdmi->dev, "it is no a hdmi register\n");
 		return count;
 	}
@@ -4008,59 +4007,30 @@ static void dw_hdmi_register_hdcp(struct device *dev, struct dw_hdmi *hdmi,
 }
 
 static const struct regmap_config hdmi_regmap_8bit_config = {
-	.reg_bits = 32,
-	.val_bits = 8,
-	.reg_stride = 1,
-	.max_register = HDMI_I2CM_MAX_REG,
+	.reg_bits	= 32,
+	.val_bits	= 8,
+	.reg_stride	= 1,
+	.max_register	= HDMI_I2CM_SDA_HOLD,
 };
 
 static const struct regmap_config hdmi_regmap_32bit_config = {
-	.reg_bits = 32,
-	.val_bits = 32,
-	.reg_stride = 4,
-	.max_register = HDMI_I2CM_MAX_REG << 2,
+	.reg_bits	= 32,
+	.val_bits	= 32,
+	.reg_stride	= 4,
+	.max_register	= HDMI_I2CM_SDA_HOLD << 2,
 };
 
-static void dw_hdmi_reg_initial(struct dw_hdmi *hdmi)
-{
-	if (hdmi_readb(hdmi, HDMI_IH_MUTE)) {
-		initialize_hdmi_ih_mutes(hdmi);
-		hdmi_writeb(hdmi, HDMI_PHY_I2CM_INT_ADDR_DONE_POL,
-			    HDMI_PHY_I2CM_INT_ADDR);
-
-		hdmi_writeb(hdmi,
-			    HDMI_PHY_I2CM_CTLINT_ADDR_NAC_POL |
-				    HDMI_PHY_I2CM_CTLINT_ADDR_ARBITRATION_POL,
-			    HDMI_PHY_I2CM_CTLINT_ADDR);
-
-		hdmi_writeb(hdmi, HDMI_PHY_HPD | HDMI_PHY_RX_SENSE,
-			    HDMI_PHY_POL0);
-		hdmi_writeb(hdmi, hdmi->phy_mask, HDMI_PHY_MASK0);
-		hdmi_writeb(hdmi,
-			    ~(HDMI_IH_PHY_STAT0_HPD |
-			      HDMI_IH_PHY_STAT0_RX_SENSE),
-			    HDMI_IH_MUTE_PHY_STAT0);
-	}
-}
-
 static void dw_hdmi_init_hw(struct dw_hdmi *hdmi)
 {
-	if (!hdmi) {
-		printk("Hdmi has not been initialized\n");
-		return;
-	}
+	initialize_hdmi_ih_mutes(hdmi);
 
-	mutex_lock(&hdmi->mutex);
-	dw_hdmi_reg_initial(hdmi);
 	/*
-     * Reset HDMI DDC I2C master controller and mute I2CM interrupts.
-     * Even if we are using a separate i2c adapter doing this doesn't
-     * hurt.
-     */
-	if (hdmi->i2c)
-		dw_hdmi_i2c_init(hdmi);
-	if (hdmi->irq)
-		enable_irq(hdmi->irq);
+	 * Reset HDMI DDC I2C master controller and mute I2CM interrupts.
+	 * Even if we are using a separate i2c adapter doing this doesn't
+	 * hurt.
+	 */
+	dw_hdmi_i2c_init(hdmi);
+
 	if (hdmi->phy.ops->setup_hpd)
 		hdmi->phy.ops->setup_hpd(hdmi, hdmi->phy.data);
 
@@ -4078,7 +4048,6 @@ static void dw_hdmi_init_hw(struct dw_hdmi *hdmi)
 			mod_delayed_work(hdmi->workqueue, &hdmi->work,
 					 msecs_to_jiffies(20));
 		}
-	mutex_unlock(&hdmi->mutex);
 }
 
 /* -----------------------------------------------------------------------------
@@ -4093,14 +4062,15 @@ static int dw_hdmi_parse_dt(struct dw_hdmi *hdmi)
 	if (!hdmi->plat_data->output_port)
 		return 0;
 
-	endpoint = of_graph_get_endpoint_by_regs(
-		hdmi->dev->of_node, hdmi->plat_data->output_port, -1);
+	endpoint = of_graph_get_endpoint_by_regs(hdmi->dev->of_node,
+						 hdmi->plat_data->output_port,
+						 -1);
 	if (!endpoint) {
 		/*
-         * On platforms whose bindings don't make the output port
-         * mandatory (such as Rockchip) the plat_data->output_port
-         * field isn't set, so it's safe to make this a fatal error.
-         */
+		 * On platforms whose bindings don't make the output port
+		 * mandatory (such as Rockchip) the plat_data->output_port
+		 * field isn't set, so it's safe to make this a fatal error.
+		 */
 		dev_err(hdmi->dev, "Missing endpoint in port@%u\n",
 			hdmi->plat_data->output_port);
 		return -ENODEV;
@@ -4129,6 +4099,12 @@ static int dw_hdmi_parse_dt(struct dw_hdmi *hdmi)
 	return 0;
 }
 
+bool dw_hdmi_bus_fmt_is_420(struct dw_hdmi *hdmi)
+{
+	return hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format);
+}
+EXPORT_SYMBOL_GPL(dw_hdmi_bus_fmt_is_420);
+
 void dw_hdmi_enable_video(struct dw_hdmi *hdmi)
 {
 	dev_info(hdmi->dev, "%s", __func__);
@@ -4194,14 +4170,6 @@ struct dw_hdmi *dw_hdmi_probe(struct platform_device *pdev,
 		dev_dbg(hdmi->dev, "no ddc property found\n");
 	}
 
-	ret = device_property_read_u32(&pdev->dev, "eswin-plat",
-				       &hdmi->eswin_plat);
-	if (0 != ret) {
-		dev_warn(&pdev->dev, "Failed to get eswin platform\n");
-		hdmi->eswin_plat = 0;
-	}
-	dev_info(hdmi->dev, "eswin platform:%d\n", hdmi->eswin_plat);
-
 	if (!plat_data->regm) {
 		const struct regmap_config *reg_config;
 
@@ -4325,8 +4293,8 @@ struct dw_hdmi *dw_hdmi_probe(struct platform_device *pdev,
 	}
 
 	/* Product and revision IDs */
-	hdmi->version = (hdmi_readb(hdmi, HDMI_DESIGN_ID) << 8) |
-			(hdmi_readb(hdmi, HDMI_REVISION_ID) << 0);
+	hdmi->version = (hdmi_readb(hdmi, HDMI_DESIGN_ID) << 8)
+		      | (hdmi_readb(hdmi, HDMI_REVISION_ID) << 0);
 	prod_id0 = hdmi_readb(hdmi, HDMI_PRODUCT_ID0);
 	prod_id1 = hdmi_readb(hdmi, HDMI_PRODUCT_ID1);
 
@@ -4347,6 +4315,7 @@ struct dw_hdmi *dw_hdmi_probe(struct platform_device *pdev,
 		 prod_id1 & HDMI_PRODUCT_ID1_HDCP ? "with" : "without",
 		 hdmi->phy.name);
 
+	dw_hdmi_init_hw(hdmi);
 	init_hpd_work(hdmi);
 
 	irq = platform_get_irq(pdev, 0);
@@ -4355,15 +4324,16 @@ struct dw_hdmi *dw_hdmi_probe(struct platform_device *pdev,
 		goto err_iahb;
 	}
 
-	ret = devm_request_threaded_irq(dev, irq, dw_hdmi_hardirq, dw_hdmi_irq,
-					IRQF_SHARED, dev_name(dev), hdmi);
+	ret = devm_request_threaded_irq(dev, irq, dw_hdmi_hardirq,
+					dw_hdmi_irq, IRQF_SHARED,
+					dev_name(dev), hdmi);
 	if (ret)
 		goto err_iahb;
 
 	/*
-     * To prevent overflows in HDMI_IH_FC_STAT2, set the clk regenerator
-     * N and cts values before enabling phy
-     */
+	 * To prevent overflows in HDMI_IH_FC_STAT2, set the clk regenerator
+	 * N and cts values before enabling phy
+	 */
 	hdmi_init_clk_regenerator(hdmi);
 
 	/* If DDC bus is not specified, try to register HDMI I2C bus */
@@ -4379,9 +4349,8 @@ struct dw_hdmi *dw_hdmi_probe(struct platform_device *pdev,
 			if (IS_ERR(hdmi->default_state) ||
 			    IS_ERR(hdmi->unwedge_state)) {
 				if (!IS_ERR(hdmi->unwedge_state))
-					dev_warn(
-						dev,
-						"Unwedge requires default pinctrl\n");
+					dev_warn(dev,
+						 "Unwedge requires default pinctrl\n");
 				hdmi->default_state = NULL;
 				hdmi->unwedge_state = NULL;
 			}
@@ -4390,25 +4359,14 @@ struct dw_hdmi *dw_hdmi_probe(struct platform_device *pdev,
 		hdmi->ddc = dw_hdmi_i2c_adapter(hdmi);
 		if (IS_ERR(hdmi->ddc))
 			hdmi->ddc = NULL;
-
-		/*
-         * Read high and low time from device tree. If not available use
-         * the default timing scl clock rate is about 99.6KHz.
-         */
-		if (of_property_read_u32(np, "ddc-i2c-scl-high-time-ns",
-					 &hdmi->i2c->scl_high_ns))
-			hdmi->i2c->scl_high_ns = 4708;
-		if (of_property_read_u32(np, "ddc-i2c-scl-low-time-ns",
-					 &hdmi->i2c->scl_low_ns))
-			hdmi->i2c->scl_low_ns = 4916;
 	}
 
-	dw_hdmi_init_hw(hdmi);
 	hdmi->bridge.driver_private = hdmi;
 	hdmi->bridge.funcs = &dw_hdmi_bridge_funcs;
-	hdmi->bridge.ops =
-		DRM_BRIDGE_OP_DETECT | DRM_BRIDGE_OP_EDID | DRM_BRIDGE_OP_HPD;
+	hdmi->bridge.ops = DRM_BRIDGE_OP_DETECT | DRM_BRIDGE_OP_EDID
+			 | DRM_BRIDGE_OP_HPD;
 	hdmi->bridge.interlace_allowed = true;
+	hdmi->bridge.ddc = hdmi->ddc;
 #ifdef CONFIG_OF
 	hdmi->bridge.of_node = pdev->dev.of_node;
 #endif
@@ -4439,10 +4397,10 @@ struct dw_hdmi *dw_hdmi_probe(struct platform_device *pdev,
 	} else if (config0 & HDMI_CONFIG0_I2S) {
 		struct dw_hdmi_i2s_audio_data audio;
 
-		audio.hdmi = hdmi;
-		audio.get_eld = hdmi_audio_get_eld;
-		audio.write = hdmi_writeb;
-		audio.read = hdmi_readb;
+		audio.hdmi	= hdmi;
+		audio.get_eld	= hdmi_audio_get_eld;
+		audio.write	= hdmi_writeb;
+		audio.read	= hdmi_readb;
 		hdmi->enable_audio = dw_hdmi_i2s_audio_enable;
 		hdmi->disable_audio = dw_hdmi_i2s_audio_disable;
 
@@ -4451,6 +4409,24 @@ struct dw_hdmi *dw_hdmi_probe(struct platform_device *pdev,
 		pdevinfo.size_data = sizeof(audio);
 		pdevinfo.dma_mask = DMA_BIT_MASK(32);
 		hdmi->audio = platform_device_register_full(&pdevinfo);
+	} else if (iores && config3 & HDMI_CONFIG3_GPAUD) {
+		struct dw_hdmi_audio_data audio;
+
+		audio.phys = iores->start;
+		audio.base = hdmi->regs;
+		audio.irq = irq;
+		audio.hdmi = hdmi;
+		audio.get_eld = hdmi_audio_get_eld;
+
+		hdmi->enable_audio = dw_hdmi_gp_audio_enable;
+		hdmi->disable_audio = dw_hdmi_gp_audio_disable;
+
+		pdevinfo.name = "dw-hdmi-gp-audio";
+		pdevinfo.id = PLATFORM_DEVID_NONE;
+		pdevinfo.data = &audio;
+		pdevinfo.size_data = sizeof(audio);
+		pdevinfo.dma_mask = DMA_BIT_MASK(32);
+		hdmi->audio = platform_device_register_full(&pdevinfo);
 	}
 
 	if (!plat_data->disable_cec && (config0 & HDMI_CONFIG0_CEC)) {
@@ -4477,11 +4453,8 @@ struct dw_hdmi *dw_hdmi_probe(struct platform_device *pdev,
 	return hdmi;
 
 err_iahb:
-	if (hdmi->i2c)
-		i2c_del_adapter(&hdmi->i2c->adap);
 	clk_disable_unprepare(hdmi->iahb_clk);
-	if (hdmi->cec_clk)
-		clk_disable_unprepare(hdmi->cec_clk);
+	clk_disable_unprepare(hdmi->cec_clk);
 err_isfr:
 	clk_disable_unprepare(hdmi->isfr_clk);
 err_res:
@@ -4497,9 +4470,6 @@ void dw_hdmi_remove(struct dw_hdmi *hdmi)
 
 	drm_bridge_remove(&hdmi->bridge);
 
-	if (hdmi->irq)
-		disable_irq(hdmi->irq);
-
 	cancel_delayed_work(&hdmi->work);
 	flush_workqueue(hdmi->workqueue);
 	destroy_workqueue(hdmi->workqueue);
@@ -4612,6 +4582,10 @@ void dw_hdmi_resume(struct dw_hdmi *hdmi)
 }
 EXPORT_SYMBOL_GPL(dw_hdmi_resume);
 
+MODULE_AUTHOR("Sascha Hauer <s.hauer@pengutronix.de>");
+MODULE_AUTHOR("Andy Yan <andy.yan@rock-chips.com>");
+MODULE_AUTHOR("Yakir Yang <ykk@rock-chips.com>");
+MODULE_AUTHOR("Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>");
 MODULE_DESCRIPTION("DW HDMI transmitter driver");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("platform:dw-hdmi");
diff --git a/drivers/gpu/drm/eswin/dw-hdmi.h b/drivers/gpu/drm/eswin/dw-hdmi.h
new file mode 100644
index 000000000000..147774f90094
--- /dev/null
+++ b/drivers/gpu/drm/eswin/dw-hdmi.h
@@ -0,0 +1,1272 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ */
+
+#ifndef __DW_HDMI_H__
+#define __DW_HDMI_H__
+
+#include <sound/hdmi-codec.h>
+#include <drm/drm_property.h>
+
+extern struct platform_driver dw_hdmi_eswin_pltfm_driver;
+extern struct platform_driver snd_dw_hdmi_driver;
+extern struct platform_driver dw_hdmi_cec_driver;
+extern struct platform_driver dw_hdmi_hdcp_driver;
+extern struct platform_driver dw_hdmi_hdcp2_driver;
+
+/* Identification Registers */
+#define HDMI_DESIGN_ID                          0x0000
+#define HDMI_REVISION_ID                        0x0001
+#define HDMI_PRODUCT_ID0                        0x0002
+#define HDMI_PRODUCT_ID1                        0x0003
+#define HDMI_CONFIG0_ID                         0x0004
+#define HDMI_CONFIG1_ID                         0x0005
+#define HDMI_CONFIG2_ID                         0x0006
+#define HDMI_CONFIG3_ID                         0x0007
+
+/* Interrupt Registers */
+#define HDMI_IH_FC_STAT0                        0x0100
+#define HDMI_IH_FC_STAT1                        0x0101
+#define HDMI_IH_FC_STAT2                        0x0102
+#define HDMI_IH_AS_STAT0                        0x0103
+#define HDMI_IH_PHY_STAT0                       0x0104
+#define HDMI_IH_I2CM_STAT0                      0x0105
+#define HDMI_IH_CEC_STAT0                       0x0106
+#define HDMI_IH_VP_STAT0                        0x0107
+#define HDMI_IH_I2CMPHY_STAT0                   0x0108
+#define HDMI_IH_AHBDMAAUD_STAT0                 0x0109
+
+#define HDMI_IH_MUTE_FC_STAT0                   0x0180
+#define HDMI_IH_MUTE_FC_STAT1                   0x0181
+#define HDMI_IH_MUTE_FC_STAT2                   0x0182
+#define HDMI_IH_MUTE_AS_STAT0                   0x0183
+#define HDMI_IH_MUTE_PHY_STAT0                  0x0184
+#define HDMI_IH_MUTE_I2CM_STAT0                 0x0185
+#define HDMI_IH_MUTE_CEC_STAT0                  0x0186
+#define HDMI_IH_MUTE_VP_STAT0                   0x0187
+#define HDMI_IH_MUTE_I2CMPHY_STAT0              0x0188
+#define HDMI_IH_MUTE_AHBDMAAUD_STAT0            0x0189
+#define HDMI_IH_MUTE                            0x01FF
+
+/* Video Sample Registers */
+#define HDMI_TX_INVID0                          0x0200
+#define HDMI_TX_INSTUFFING                      0x0201
+#define HDMI_TX_GYDATA0                         0x0202
+#define HDMI_TX_GYDATA1                         0x0203
+#define HDMI_TX_RCRDATA0                        0x0204
+#define HDMI_TX_RCRDATA1                        0x0205
+#define HDMI_TX_BCBDATA0                        0x0206
+#define HDMI_TX_BCBDATA1                        0x0207
+
+/* Video Packetizer Registers */
+#define HDMI_VP_STATUS                          0x0800
+#define HDMI_VP_PR_CD                           0x0801
+#define HDMI_VP_STUFF                           0x0802
+#define HDMI_VP_REMAP                           0x0803
+#define HDMI_VP_CONF                            0x0804
+#define HDMI_VP_STAT                            0x0805
+#define HDMI_VP_INT                             0x0806
+#define HDMI_VP_MASK                            0x0807
+#define HDMI_VP_POL                             0x0808
+
+/* Frame Composer Registers */
+#define HDMI_FC_INVIDCONF                       0x1000
+#define HDMI_FC_INHACTV0                        0x1001
+#define HDMI_FC_INHACTV1                        0x1002
+#define HDMI_FC_INHBLANK0                       0x1003
+#define HDMI_FC_INHBLANK1                       0x1004
+#define HDMI_FC_INVACTV0                        0x1005
+#define HDMI_FC_INVACTV1                        0x1006
+#define HDMI_FC_INVBLANK                        0x1007
+#define HDMI_FC_HSYNCINDELAY0                   0x1008
+#define HDMI_FC_HSYNCINDELAY1                   0x1009
+#define HDMI_FC_HSYNCINWIDTH0                   0x100A
+#define HDMI_FC_HSYNCINWIDTH1                   0x100B
+#define HDMI_FC_VSYNCINDELAY                    0x100C
+#define HDMI_FC_VSYNCINWIDTH                    0x100D
+#define HDMI_FC_INFREQ0                         0x100E
+#define HDMI_FC_INFREQ1                         0x100F
+#define HDMI_FC_INFREQ2                         0x1010
+#define HDMI_FC_CTRLDUR                         0x1011
+#define HDMI_FC_EXCTRLDUR                       0x1012
+#define HDMI_FC_EXCTRLSPAC                      0x1013
+#define HDMI_FC_CH0PREAM                        0x1014
+#define HDMI_FC_CH1PREAM                        0x1015
+#define HDMI_FC_CH2PREAM                        0x1016
+#define HDMI_FC_AVICONF3                        0x1017
+#define HDMI_FC_GCP                             0x1018
+#define HDMI_FC_AVICONF0                        0x1019
+#define HDMI_FC_AVICONF1                        0x101A
+#define HDMI_FC_AVICONF2                        0x101B
+#define HDMI_FC_AVIVID                          0x101C
+#define HDMI_FC_AVIETB0                         0x101D
+#define HDMI_FC_AVIETB1                         0x101E
+#define HDMI_FC_AVISBB0                         0x101F
+#define HDMI_FC_AVISBB1                         0x1020
+#define HDMI_FC_AVIELB0                         0x1021
+#define HDMI_FC_AVIELB1                         0x1022
+#define HDMI_FC_AVISRB0                         0x1023
+#define HDMI_FC_AVISRB1                         0x1024
+#define HDMI_FC_AUDICONF0                       0x1025
+#define HDMI_FC_AUDICONF1                       0x1026
+#define HDMI_FC_AUDICONF2                       0x1027
+#define HDMI_FC_AUDICONF3                       0x1028
+#define HDMI_FC_VSDIEEEID0                      0x1029
+#define HDMI_FC_VSDSIZE                         0x102A
+#define HDMI_FC_VSDIEEEID1                      0x1030
+#define HDMI_FC_VSDIEEEID2                      0x1031
+#define HDMI_FC_VSDPAYLOAD0                     0x1032
+#define HDMI_FC_VSDPAYLOAD1                     0x1033
+#define HDMI_FC_VSDPAYLOAD2                     0x1034
+#define HDMI_FC_VSDPAYLOAD3                     0x1035
+#define HDMI_FC_VSDPAYLOAD4                     0x1036
+#define HDMI_FC_VSDPAYLOAD5                     0x1037
+#define HDMI_FC_VSDPAYLOAD6                     0x1038
+#define HDMI_FC_VSDPAYLOAD7                     0x1039
+#define HDMI_FC_VSDPAYLOAD8                     0x103A
+#define HDMI_FC_VSDPAYLOAD9                     0x103B
+#define HDMI_FC_VSDPAYLOAD10                    0x103C
+#define HDMI_FC_VSDPAYLOAD11                    0x103D
+#define HDMI_FC_VSDPAYLOAD12                    0x103E
+#define HDMI_FC_VSDPAYLOAD13                    0x103F
+#define HDMI_FC_VSDPAYLOAD14                    0x1040
+#define HDMI_FC_VSDPAYLOAD15                    0x1041
+#define HDMI_FC_VSDPAYLOAD16                    0x1042
+#define HDMI_FC_VSDPAYLOAD17                    0x1043
+#define HDMI_FC_VSDPAYLOAD18                    0x1044
+#define HDMI_FC_VSDPAYLOAD19                    0x1045
+#define HDMI_FC_VSDPAYLOAD20                    0x1046
+#define HDMI_FC_VSDPAYLOAD21                    0x1047
+#define HDMI_FC_VSDPAYLOAD22                    0x1048
+#define HDMI_FC_VSDPAYLOAD23                    0x1049
+#define HDMI_FC_SPDVENDORNAME0                  0x104A
+#define HDMI_FC_SPDVENDORNAME1                  0x104B
+#define HDMI_FC_SPDVENDORNAME2                  0x104C
+#define HDMI_FC_SPDVENDORNAME3                  0x104D
+#define HDMI_FC_SPDVENDORNAME4                  0x104E
+#define HDMI_FC_SPDVENDORNAME5                  0x104F
+#define HDMI_FC_SPDVENDORNAME6                  0x1050
+#define HDMI_FC_SPDVENDORNAME7                  0x1051
+#define HDMI_FC_SDPPRODUCTNAME0                 0x1052
+#define HDMI_FC_SDPPRODUCTNAME1                 0x1053
+#define HDMI_FC_SDPPRODUCTNAME2                 0x1054
+#define HDMI_FC_SDPPRODUCTNAME3                 0x1055
+#define HDMI_FC_SDPPRODUCTNAME4                 0x1056
+#define HDMI_FC_SDPPRODUCTNAME5                 0x1057
+#define HDMI_FC_SDPPRODUCTNAME6                 0x1058
+#define HDMI_FC_SDPPRODUCTNAME7                 0x1059
+#define HDMI_FC_SDPPRODUCTNAME8                 0x105A
+#define HDMI_FC_SDPPRODUCTNAME9                 0x105B
+#define HDMI_FC_SDPPRODUCTNAME10                0x105C
+#define HDMI_FC_SDPPRODUCTNAME11                0x105D
+#define HDMI_FC_SDPPRODUCTNAME12                0x105E
+#define HDMI_FC_SDPPRODUCTNAME13                0x105F
+#define HDMI_FC_SDPPRODUCTNAME14                0x1060
+#define HDMI_FC_SPDPRODUCTNAME15                0x1061
+#define HDMI_FC_SPDDEVICEINF                    0x1062
+#define HDMI_FC_AUDSCONF                        0x1063
+#define HDMI_FC_AUDSSTAT                        0x1064
+#define HDMI_FC_AUDSV                           0x1065
+#define HDMI_FC_AUDSU                           0x1066
+#define HDMI_FC_AUDSCHNLS0                       0x1067
+#define HDMI_FC_AUDSCHNLS1                       0x1068
+#define HDMI_FC_AUDSCHNLS2                       0x1069
+#define HDMI_FC_AUDSCHNLS3                       0x106A
+#define HDMI_FC_AUDSCHNLS4                       0x106B
+#define HDMI_FC_AUDSCHNLS5                       0x106C
+#define HDMI_FC_AUDSCHNLS6                       0x106D
+#define HDMI_FC_AUDSCHNLS7                       0x106E
+#define HDMI_FC_AUDSCHNLS8                       0x106F
+#define HDMI_FC_DATACH0FILL                     0x1070
+#define HDMI_FC_DATACH1FILL                     0x1071
+#define HDMI_FC_DATACH2FILL                     0x1072
+#define HDMI_FC_CTRLQHIGH                       0x1073
+#define HDMI_FC_CTRLQLOW                        0x1074
+#define HDMI_FC_ACP0                            0x1075
+#define HDMI_FC_ACP28                           0x1076
+#define HDMI_FC_ACP27                           0x1077
+#define HDMI_FC_ACP26                           0x1078
+#define HDMI_FC_ACP25                           0x1079
+#define HDMI_FC_ACP24                           0x107A
+#define HDMI_FC_ACP23                           0x107B
+#define HDMI_FC_ACP22                           0x107C
+#define HDMI_FC_ACP21                           0x107D
+#define HDMI_FC_ACP20                           0x107E
+#define HDMI_FC_ACP19                           0x107F
+#define HDMI_FC_ACP18                           0x1080
+#define HDMI_FC_ACP17                           0x1081
+#define HDMI_FC_ACP16                           0x1082
+#define HDMI_FC_ACP15                           0x1083
+#define HDMI_FC_ACP14                           0x1084
+#define HDMI_FC_ACP13                           0x1085
+#define HDMI_FC_ACP12                           0x1086
+#define HDMI_FC_ACP11                           0x1087
+#define HDMI_FC_ACP10                           0x1088
+#define HDMI_FC_ACP9                            0x1089
+#define HDMI_FC_ACP8                            0x108A
+#define HDMI_FC_ACP7                            0x108B
+#define HDMI_FC_ACP6                            0x108C
+#define HDMI_FC_ACP5                            0x108D
+#define HDMI_FC_ACP4                            0x108E
+#define HDMI_FC_ACP3                            0x108F
+#define HDMI_FC_ACP2                            0x1090
+#define HDMI_FC_ACP1                            0x1091
+#define HDMI_FC_ISCR1_0                         0x1092
+#define HDMI_FC_ISCR1_16                        0x1093
+#define HDMI_FC_ISCR1_15                        0x1094
+#define HDMI_FC_ISCR1_14                        0x1095
+#define HDMI_FC_ISCR1_13                        0x1096
+#define HDMI_FC_ISCR1_12                        0x1097
+#define HDMI_FC_ISCR1_11                        0x1098
+#define HDMI_FC_ISCR1_10                        0x1099
+#define HDMI_FC_ISCR1_9                         0x109A
+#define HDMI_FC_ISCR1_8                         0x109B
+#define HDMI_FC_ISCR1_7                         0x109C
+#define HDMI_FC_ISCR1_6                         0x109D
+#define HDMI_FC_ISCR1_5                         0x109E
+#define HDMI_FC_ISCR1_4                         0x109F
+#define HDMI_FC_ISCR1_3                         0x10A0
+#define HDMI_FC_ISCR1_2                         0x10A1
+#define HDMI_FC_ISCR1_1                         0x10A2
+#define HDMI_FC_ISCR2_15                        0x10A3
+#define HDMI_FC_ISCR2_14                        0x10A4
+#define HDMI_FC_ISCR2_13                        0x10A5
+#define HDMI_FC_ISCR2_12                        0x10A6
+#define HDMI_FC_ISCR2_11                        0x10A7
+#define HDMI_FC_ISCR2_10                        0x10A8
+#define HDMI_FC_ISCR2_9                         0x10A9
+#define HDMI_FC_ISCR2_8                         0x10AA
+#define HDMI_FC_ISCR2_7                         0x10AB
+#define HDMI_FC_ISCR2_6                         0x10AC
+#define HDMI_FC_ISCR2_5                         0x10AD
+#define HDMI_FC_ISCR2_4                         0x10AE
+#define HDMI_FC_ISCR2_3                         0x10AF
+#define HDMI_FC_ISCR2_2                         0x10B0
+#define HDMI_FC_ISCR2_1                         0x10B1
+#define HDMI_FC_ISCR2_0                         0x10B2
+#define HDMI_FC_DATAUTO0                        0x10B3
+#define HDMI_FC_DATAUTO1                        0x10B4
+#define HDMI_FC_DATAUTO2                        0x10B5
+#define HDMI_FC_DATMAN                          0x10B6
+#define HDMI_FC_DATAUTO3                        0x10B7
+#define HDMI_FC_RDRB0                           0x10B8
+#define HDMI_FC_RDRB1                           0x10B9
+#define HDMI_FC_RDRB2                           0x10BA
+#define HDMI_FC_RDRB3                           0x10BB
+#define HDMI_FC_RDRB4                           0x10BC
+#define HDMI_FC_RDRB5                           0x10BD
+#define HDMI_FC_RDRB6                           0x10BE
+#define HDMI_FC_RDRB7                           0x10BF
+#define HDMI_FC_STAT0                           0x10D0
+#define HDMI_FC_INT0                            0x10D1
+#define HDMI_FC_MASK0                           0x10D2
+#define HDMI_FC_POL0                            0x10D3
+#define HDMI_FC_STAT1                           0x10D4
+#define HDMI_FC_INT1                            0x10D5
+#define HDMI_FC_MASK1                           0x10D6
+#define HDMI_FC_POL1                            0x10D7
+#define HDMI_FC_STAT2                           0x10D8
+#define HDMI_FC_INT2                            0x10D9
+#define HDMI_FC_MASK2                           0x10DA
+#define HDMI_FC_POL2                            0x10DB
+#define HDMI_FC_PRCONF                          0x10E0
+#define HDMI_FC_SCRAMBLER_CTRL                  0x10E1
+#define HDMI_FC_PACKET_TX_EN                    0x10E3
+
+#define HDMI_FC_GMD_STAT                        0x1100
+#define HDMI_FC_GMD_EN                          0x1101
+#define HDMI_FC_GMD_UP                          0x1102
+#define HDMI_FC_GMD_CONF                        0x1103
+#define HDMI_FC_GMD_HB                          0x1104
+#define HDMI_FC_GMD_PB0                         0x1105
+#define HDMI_FC_GMD_PB1                         0x1106
+#define HDMI_FC_GMD_PB2                         0x1107
+#define HDMI_FC_GMD_PB3                         0x1108
+#define HDMI_FC_GMD_PB4                         0x1109
+#define HDMI_FC_GMD_PB5                         0x110A
+#define HDMI_FC_GMD_PB6                         0x110B
+#define HDMI_FC_GMD_PB7                         0x110C
+#define HDMI_FC_GMD_PB8                         0x110D
+#define HDMI_FC_GMD_PB9                         0x110E
+#define HDMI_FC_GMD_PB10                        0x110F
+#define HDMI_FC_GMD_PB11                        0x1110
+#define HDMI_FC_GMD_PB12                        0x1111
+#define HDMI_FC_GMD_PB13                        0x1112
+#define HDMI_FC_GMD_PB14                        0x1113
+#define HDMI_FC_GMD_PB15                        0x1114
+#define HDMI_FC_GMD_PB16                        0x1115
+#define HDMI_FC_GMD_PB17                        0x1116
+#define HDMI_FC_GMD_PB18                        0x1117
+#define HDMI_FC_GMD_PB19                        0x1118
+#define HDMI_FC_GMD_PB20                        0x1119
+#define HDMI_FC_GMD_PB21                        0x111A
+#define HDMI_FC_GMD_PB22                        0x111B
+#define HDMI_FC_GMD_PB23                        0x111C
+#define HDMI_FC_GMD_PB24                        0x111D
+#define HDMI_FC_GMD_PB25                        0x111E
+#define HDMI_FC_GMD_PB26                        0x111F
+#define HDMI_FC_GMD_PB27                        0x1120
+
+#define HDMI_FC_DRM_UP                          0x1167
+#define HDMI_FC_DRM_HB0                         0x1168
+#define HDMI_FC_DRM_HB1                         0x1169
+#define HDMI_FC_DRM_PB0                         0x116A
+#define HDMI_FC_DRM_PB1                         0x116B
+#define HDMI_FC_DRM_PB2                         0x116C
+#define HDMI_FC_DRM_PB3                         0x116D
+#define HDMI_FC_DRM_PB4                         0x116E
+#define HDMI_FC_DRM_PB5                         0x116F
+#define HDMI_FC_DRM_PB6                         0x1170
+#define HDMI_FC_DRM_PB7                         0x1171
+#define HDMI_FC_DRM_PB8                         0x1172
+#define HDMI_FC_DRM_PB9                         0x1173
+#define HDMI_FC_DRM_PB10                        0x1174
+#define HDMI_FC_DRM_PB11                        0x1175
+#define HDMI_FC_DRM_PB12                        0x1176
+#define HDMI_FC_DRM_PB13                        0x1177
+#define HDMI_FC_DRM_PB14                        0x1178
+#define HDMI_FC_DRM_PB15                        0x1179
+#define HDMI_FC_DRM_PB16                        0x117A
+#define HDMI_FC_DRM_PB17                        0x117B
+#define HDMI_FC_DRM_PB18                        0x117C
+#define HDMI_FC_DRM_PB19                        0x117D
+#define HDMI_FC_DRM_PB20                        0x117E
+#define HDMI_FC_DRM_PB21                        0x117F
+#define HDMI_FC_DRM_PB22                        0x1180
+#define HDMI_FC_DRM_PB23                        0x1181
+#define HDMI_FC_DRM_PB24                        0x1182
+#define HDMI_FC_DRM_PB25                        0x1183
+#define HDMI_FC_DRM_PB26                        0x1184
+
+#define HDMI_FC_DBGFORCE                        0x1200
+#define HDMI_FC_DBGAUD0CH0                      0x1201
+#define HDMI_FC_DBGAUD1CH0                      0x1202
+#define HDMI_FC_DBGAUD2CH0                      0x1203
+#define HDMI_FC_DBGAUD0CH1                      0x1204
+#define HDMI_FC_DBGAUD1CH1                      0x1205
+#define HDMI_FC_DBGAUD2CH1                      0x1206
+#define HDMI_FC_DBGAUD0CH2                      0x1207
+#define HDMI_FC_DBGAUD1CH2                      0x1208
+#define HDMI_FC_DBGAUD2CH2                      0x1209
+#define HDMI_FC_DBGAUD0CH3                      0x120A
+#define HDMI_FC_DBGAUD1CH3                      0x120B
+#define HDMI_FC_DBGAUD2CH3                      0x120C
+#define HDMI_FC_DBGAUD0CH4                      0x120D
+#define HDMI_FC_DBGAUD1CH4                      0x120E
+#define HDMI_FC_DBGAUD2CH4                      0x120F
+#define HDMI_FC_DBGAUD0CH5                      0x1210
+#define HDMI_FC_DBGAUD1CH5                      0x1211
+#define HDMI_FC_DBGAUD2CH5                      0x1212
+#define HDMI_FC_DBGAUD0CH6                      0x1213
+#define HDMI_FC_DBGAUD1CH6                      0x1214
+#define HDMI_FC_DBGAUD2CH6                      0x1215
+#define HDMI_FC_DBGAUD0CH7                      0x1216
+#define HDMI_FC_DBGAUD1CH7                      0x1217
+#define HDMI_FC_DBGAUD2CH7                      0x1218
+#define HDMI_FC_DBGTMDS0                        0x1219
+#define HDMI_FC_DBGTMDS1                        0x121A
+#define HDMI_FC_DBGTMDS2                        0x121B
+
+/* HDMI Source PHY Registers */
+#define HDMI_PHY_CONF0                          0x3000
+#define HDMI_PHY_TST0                           0x3001
+#define HDMI_PHY_TST1                           0x3002
+#define HDMI_PHY_TST2                           0x3003
+#define HDMI_PHY_STAT0                          0x3004
+#define HDMI_PHY_INT0                           0x3005
+#define HDMI_PHY_MASK0                          0x3006
+#define HDMI_PHY_POL0                           0x3007
+
+/* HDMI Master PHY Registers */
+#define HDMI_PHY_I2CM_SLAVE_ADDR                0x3020
+#define HDMI_PHY_I2CM_ADDRESS_ADDR              0x3021
+#define HDMI_PHY_I2CM_DATAO_1_ADDR              0x3022
+#define HDMI_PHY_I2CM_DATAO_0_ADDR              0x3023
+#define HDMI_PHY_I2CM_DATAI_1_ADDR              0x3024
+#define HDMI_PHY_I2CM_DATAI_0_ADDR              0x3025
+#define HDMI_PHY_I2CM_OPERATION_ADDR            0x3026
+#define HDMI_PHY_I2CM_INT_ADDR                  0x3027
+#define HDMI_PHY_I2CM_CTLINT_ADDR               0x3028
+#define HDMI_PHY_I2CM_DIV_ADDR                  0x3029
+#define HDMI_PHY_I2CM_SOFTRSTZ_ADDR             0x302a
+#define HDMI_PHY_I2CM_SS_SCL_HCNT_1_ADDR        0x302b
+#define HDMI_PHY_I2CM_SS_SCL_HCNT_0_ADDR        0x302c
+#define HDMI_PHY_I2CM_SS_SCL_LCNT_1_ADDR        0x302d
+#define HDMI_PHY_I2CM_SS_SCL_LCNT_0_ADDR        0x302e
+#define HDMI_PHY_I2CM_FS_SCL_HCNT_1_ADDR        0x302f
+#define HDMI_PHY_I2CM_FS_SCL_HCNT_0_ADDR        0x3030
+#define HDMI_PHY_I2CM_FS_SCL_LCNT_1_ADDR        0x3031
+#define HDMI_PHY_I2CM_FS_SCL_LCNT_0_ADDR        0x3032
+
+/* Audio Sampler Registers */
+#define HDMI_AUD_CONF0                          0x3100
+#define HDMI_AUD_CONF1                          0x3101
+#define HDMI_AUD_INT                            0x3102
+#define HDMI_AUD_CONF2                          0x3103
+#define HDMI_AUD_N1                             0x3200
+#define HDMI_AUD_N2                             0x3201
+#define HDMI_AUD_N3                             0x3202
+#define HDMI_AUD_CTS1                           0x3203
+#define HDMI_AUD_CTS2                           0x3204
+#define HDMI_AUD_CTS3                           0x3205
+#define HDMI_AUD_INPUTCLKFS                     0x3206
+#define HDMI_AUD_SPDIFINT			0x3302
+#define HDMI_AUD_CONF0_HBR                      0x3400
+#define HDMI_AUD_HBR_STATUS                     0x3401
+#define HDMI_AUD_HBR_INT                        0x3402
+#define HDMI_AUD_HBR_POL                        0x3403
+#define HDMI_AUD_HBR_MASK                       0x3404
+
+/*
+ * Generic Parallel Audio Interface Registers
+ * Not used as GPAUD interface is not enabled in hw
+ */
+#define HDMI_GP_CONF0                           0x3500
+#define HDMI_GP_CONF1                           0x3501
+#define HDMI_GP_CONF2                           0x3502
+#define HDMI_GP_STAT                            0x3503
+#define HDMI_GP_INT                             0x3504
+#define HDMI_GP_MASK                            0x3505
+#define HDMI_GP_POL                             0x3506
+
+/* Audio DMA Registers */
+#define HDMI_AHB_DMA_CONF0                      0x3600
+#define HDMI_AHB_DMA_START                      0x3601
+#define HDMI_AHB_DMA_STOP                       0x3602
+#define HDMI_AHB_DMA_THRSLD                     0x3603
+#define HDMI_AHB_DMA_STRADDR0                   0x3604
+#define HDMI_AHB_DMA_STRADDR1                   0x3605
+#define HDMI_AHB_DMA_STRADDR2                   0x3606
+#define HDMI_AHB_DMA_STRADDR3                   0x3607
+#define HDMI_AHB_DMA_STPADDR0                   0x3608
+#define HDMI_AHB_DMA_STPADDR1                   0x3609
+#define HDMI_AHB_DMA_STPADDR2                   0x360a
+#define HDMI_AHB_DMA_STPADDR3                   0x360b
+#define HDMI_AHB_DMA_BSTADDR0                   0x360c
+#define HDMI_AHB_DMA_BSTADDR1                   0x360d
+#define HDMI_AHB_DMA_BSTADDR2                   0x360e
+#define HDMI_AHB_DMA_BSTADDR3                   0x360f
+#define HDMI_AHB_DMA_MBLENGTH0                  0x3610
+#define HDMI_AHB_DMA_MBLENGTH1                  0x3611
+#define HDMI_AHB_DMA_STAT                       0x3612
+#define HDMI_AHB_DMA_INT                        0x3613
+#define HDMI_AHB_DMA_MASK                       0x3614
+#define HDMI_AHB_DMA_POL                        0x3615
+#define HDMI_AHB_DMA_CONF1                      0x3616
+#define HDMI_AHB_DMA_BUFFSTAT                   0x3617
+#define HDMI_AHB_DMA_BUFFINT                    0x3618
+#define HDMI_AHB_DMA_BUFFMASK                   0x3619
+#define HDMI_AHB_DMA_BUFFPOL                    0x361a
+
+/* Main Controller Registers */
+#define HDMI_MC_SFRDIV                          0x4000
+#define HDMI_MC_CLKDIS                          0x4001
+#define HDMI_MC_SWRSTZ                          0x4002
+#define HDMI_MC_OPCTRL                          0x4003
+#define HDMI_MC_FLOWCTRL                        0x4004
+#define HDMI_MC_PHYRSTZ                         0x4005
+#define HDMI_MC_LOCKONCLOCK                     0x4006
+#define HDMI_MC_HEACPHY_RST                     0x4007
+
+/* Color Space  Converter Registers */
+#define HDMI_CSC_CFG                            0x4100
+#define HDMI_CSC_SCALE                          0x4101
+#define HDMI_CSC_COEF_A1_MSB                    0x4102
+#define HDMI_CSC_COEF_A1_LSB                    0x4103
+#define HDMI_CSC_COEF_A2_MSB                    0x4104
+#define HDMI_CSC_COEF_A2_LSB                    0x4105
+#define HDMI_CSC_COEF_A3_MSB                    0x4106
+#define HDMI_CSC_COEF_A3_LSB                    0x4107
+#define HDMI_CSC_COEF_A4_MSB                    0x4108
+#define HDMI_CSC_COEF_A4_LSB                    0x4109
+#define HDMI_CSC_COEF_B1_MSB                    0x410A
+#define HDMI_CSC_COEF_B1_LSB                    0x410B
+#define HDMI_CSC_COEF_B2_MSB                    0x410C
+#define HDMI_CSC_COEF_B2_LSB                    0x410D
+#define HDMI_CSC_COEF_B3_MSB                    0x410E
+#define HDMI_CSC_COEF_B3_LSB                    0x410F
+#define HDMI_CSC_COEF_B4_MSB                    0x4110
+#define HDMI_CSC_COEF_B4_LSB                    0x4111
+#define HDMI_CSC_COEF_C1_MSB                    0x4112
+#define HDMI_CSC_COEF_C1_LSB                    0x4113
+#define HDMI_CSC_COEF_C2_MSB                    0x4114
+#define HDMI_CSC_COEF_C2_LSB                    0x4115
+#define HDMI_CSC_COEF_C3_MSB                    0x4116
+#define HDMI_CSC_COEF_C3_LSB                    0x4117
+#define HDMI_CSC_COEF_C4_MSB                    0x4118
+#define HDMI_CSC_COEF_C4_LSB                    0x4119
+
+/* HDCP Encryption Engine Registers */
+#define HDMI_A_HDCPCFG0                         0x5000
+#define HDMI_A_HDCPCFG1                         0x5001
+#define HDMI_A_HDCPOBS0                         0x5002
+#define HDMI_A_HDCPOBS1                         0x5003
+#define HDMI_A_HDCPOBS2                         0x5004
+#define HDMI_A_HDCPOBS3                         0x5005
+#define HDMI_A_APIINTCLR                        0x5006
+#define HDMI_A_APIINTSTAT                       0x5007
+#define HDMI_A_APIINTMSK                        0x5008
+#define HDMI_A_VIDPOLCFG                        0x5009
+#define HDMI_A_OESSWCFG                         0x500A
+#define HDMI_A_TIMER1SETUP0                     0x500B
+#define HDMI_A_TIMER1SETUP1                     0x500C
+#define HDMI_A_TIMER2SETUP0                     0x500D
+#define HDMI_A_TIMER2SETUP1                     0x500E
+#define HDMI_A_100MSCFG                         0x500F
+#define HDMI_A_2SCFG0                           0x5010
+#define HDMI_A_2SCFG1                           0x5011
+#define HDMI_A_5SCFG0                           0x5012
+#define HDMI_A_5SCFG1                           0x5013
+#define HDMI_A_SRMVERLSB                        0x5014
+#define HDMI_A_SRMVERMSB                        0x5015
+#define HDMI_A_SRMCTRL                          0x5016
+#define HDMI_A_SFRSETUP                         0x5017
+#define HDMI_A_I2CHSETUP                        0x5018
+#define HDMI_A_INTSETUP                         0x5019
+#define HDMI_A_PRESETUP                         0x501A
+#define HDMI_A_SRM_BASE                         0x5020
+
+/* HDCP Registers */
+#define HDMI_HDCPREG_RMCTL                      0x780e
+#define HDMI_HDCPREG_RMSTS                      0x780f
+#define HDMI_HDCPREG_SEED0                      0x7810
+#define HDMI_HDCPREG_SEED1                      0x7811
+#define HDMI_HDCPREG_DPK0                       0x7812
+#define HDMI_HDCPREG_DPK1                       0x7813
+#define HDMI_HDCPREG_DPK2                       0x7814
+#define HDMI_HDCPREG_DPK3                       0x7815
+#define HDMI_HDCPREG_DPK4                       0x7816
+#define HDMI_HDCPREG_DPK5                       0x7817
+#define HDMI_HDCPREG_DPK6                       0x7818
+#define HDMI_HDCP2REG_CTRL                      0x7904
+#define HDMI_HDCP2REG_MASK                      0x790c
+#define HDMI_HDCP2REG_MUTE                      0x7912
+
+/* CEC Engine Registers */
+#define HDMI_CEC_CTRL                           0x7D00
+#define HDMI_CEC_STAT                           0x7D01
+#define HDMI_CEC_MASK                           0x7D02
+#define HDMI_CEC_POLARITY                       0x7D03
+#define HDMI_CEC_INT                            0x7D04
+#define HDMI_CEC_ADDR_L                         0x7D05
+#define HDMI_CEC_ADDR_H                         0x7D06
+#define HDMI_CEC_TX_CNT                         0x7D07
+#define HDMI_CEC_RX_CNT                         0x7D08
+#define HDMI_CEC_TX_DATA0                       0x7D10
+#define HDMI_CEC_TX_DATA1                       0x7D11
+#define HDMI_CEC_TX_DATA2                       0x7D12
+#define HDMI_CEC_TX_DATA3                       0x7D13
+#define HDMI_CEC_TX_DATA4                       0x7D14
+#define HDMI_CEC_TX_DATA5                       0x7D15
+#define HDMI_CEC_TX_DATA6                       0x7D16
+#define HDMI_CEC_TX_DATA7                       0x7D17
+#define HDMI_CEC_TX_DATA8                       0x7D18
+#define HDMI_CEC_TX_DATA9                       0x7D19
+#define HDMI_CEC_TX_DATA10                      0x7D1a
+#define HDMI_CEC_TX_DATA11                      0x7D1b
+#define HDMI_CEC_TX_DATA12                      0x7D1c
+#define HDMI_CEC_TX_DATA13                      0x7D1d
+#define HDMI_CEC_TX_DATA14                      0x7D1e
+#define HDMI_CEC_TX_DATA15                      0x7D1f
+#define HDMI_CEC_RX_DATA0                       0x7D20
+#define HDMI_CEC_RX_DATA1                       0x7D21
+#define HDMI_CEC_RX_DATA2                       0x7D22
+#define HDMI_CEC_RX_DATA3                       0x7D23
+#define HDMI_CEC_RX_DATA4                       0x7D24
+#define HDMI_CEC_RX_DATA5                       0x7D25
+#define HDMI_CEC_RX_DATA6                       0x7D26
+#define HDMI_CEC_RX_DATA7                       0x7D27
+#define HDMI_CEC_RX_DATA8                       0x7D28
+#define HDMI_CEC_RX_DATA9                       0x7D29
+#define HDMI_CEC_RX_DATA10                      0x7D2a
+#define HDMI_CEC_RX_DATA11                      0x7D2b
+#define HDMI_CEC_RX_DATA12                      0x7D2c
+#define HDMI_CEC_RX_DATA13                      0x7D2d
+#define HDMI_CEC_RX_DATA14                      0x7D2e
+#define HDMI_CEC_RX_DATA15                      0x7D2f
+#define HDMI_CEC_LOCK                           0x7D30
+#define HDMI_CEC_WKUPCTRL                       0x7D31
+
+/* I2C Master Registers (E-DDC) */
+#define HDMI_I2CM_SLAVE                         0x7E00
+#define HDMI_I2CM_ADDRESS                       0x7E01
+#define HDMI_I2CM_DATAO                         0x7E02
+#define HDMI_I2CM_DATAI                         0x7E03
+#define HDMI_I2CM_OPERATION                     0x7E04
+#define HDMI_I2CM_INT                           0x7E05
+#define HDMI_I2CM_CTLINT                        0x7E06
+#define HDMI_I2CM_DIV                           0x7E07
+#define HDMI_I2CM_SEGADDR                       0x7E08
+#define HDMI_I2CM_SOFTRSTZ                      0x7E09
+#define HDMI_I2CM_SEGPTR                        0x7E0A
+#define HDMI_I2CM_SS_SCL_HCNT_1_ADDR            0x7E0B
+#define HDMI_I2CM_SS_SCL_HCNT_0_ADDR            0x7E0C
+#define HDMI_I2CM_SS_SCL_LCNT_1_ADDR            0x7E0D
+#define HDMI_I2CM_SS_SCL_LCNT_0_ADDR            0x7E0E
+#define HDMI_I2CM_FS_SCL_HCNT_1_ADDR            0x7E0F
+#define HDMI_I2CM_FS_SCL_HCNT_0_ADDR            0x7E10
+#define HDMI_I2CM_FS_SCL_LCNT_1_ADDR            0x7E11
+#define HDMI_I2CM_FS_SCL_LCNT_0_ADDR            0x7E12
+#define HDMI_I2CM_SDA_HOLD                      0x7E13
+
+enum {
+/* PRODUCT_ID0 field values */
+	HDMI_PRODUCT_ID0_HDMI_TX = 0xa0,
+
+/* PRODUCT_ID1 field values */
+	HDMI_PRODUCT_ID1_HDCP = 0xc0,
+	HDMI_PRODUCT_ID1_HDMI_RX = 0x02,
+	HDMI_PRODUCT_ID1_HDMI_TX = 0x01,
+
+/* CONFIG0_ID field values */
+	HDMI_CONFIG0_I2S = 0x10,
+	HDMI_CONFIG0_CEC = 0x02,
+
+/* CONFIG1_ID field values */
+	HDMI_CONFIG1_AHB = 0x01,
+
+/* CONFIG3_ID field values */
+	HDMI_CONFIG3_AHBAUDDMA = 0x02,
+	HDMI_CONFIG3_GPAUD = 0x01,
+
+/* IH_FC_INT2 field values */
+	HDMI_IH_FC_INT2_OVERFLOW_MASK = 0x03,
+	HDMI_IH_FC_INT2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_IH_FC_INT2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* IH_FC_STAT2 field values */
+	HDMI_IH_FC_STAT2_OVERFLOW_MASK = 0x03,
+	HDMI_IH_FC_STAT2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_IH_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* IH_PHY_STAT0 field values */
+	HDMI_IH_PHY_STAT0_RX_SENSE3 = 0x20,
+	HDMI_IH_PHY_STAT0_RX_SENSE2 = 0x10,
+	HDMI_IH_PHY_STAT0_RX_SENSE1 = 0x8,
+	HDMI_IH_PHY_STAT0_RX_SENSE0 = 0x4,
+	HDMI_IH_PHY_STAT0_TX_PHY_LOCK = 0x2,
+	HDMI_IH_PHY_STAT0_HPD = 0x1,
+
+/* IH_I2CM_STAT0 and IH_MUTE_I2CM_STAT0 field values */
+	HDMI_IH_I2CM_STAT0_DONE = 0x2,
+	HDMI_IH_I2CM_STAT0_ERROR = 0x1,
+
+/* IH_MUTE_I2CMPHY_STAT0 field values */
+	HDMI_IH_MUTE_I2CMPHY_STAT0_I2CMPHYDONE = 0x2,
+	HDMI_IH_MUTE_I2CMPHY_STAT0_I2CMPHYERROR = 0x1,
+
+/* IH_AHBDMAAUD_STAT0 field values */
+	HDMI_IH_AHBDMAAUD_STAT0_ERROR = 0x20,
+	HDMI_IH_AHBDMAAUD_STAT0_LOST = 0x10,
+	HDMI_IH_AHBDMAAUD_STAT0_RETRY = 0x08,
+	HDMI_IH_AHBDMAAUD_STAT0_DONE = 0x04,
+	HDMI_IH_AHBDMAAUD_STAT0_BUFFFULL = 0x02,
+	HDMI_IH_AHBDMAAUD_STAT0_BUFFEMPTY = 0x01,
+
+/* IH_MUTE_FC_STAT2 field values */
+	HDMI_IH_MUTE_FC_STAT2_OVERFLOW_MASK = 0x03,
+	HDMI_IH_MUTE_FC_STAT2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_IH_MUTE_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* IH_MUTE_AHBDMAAUD_STAT0 field values */
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_ERROR = 0x20,
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_LOST = 0x10,
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_RETRY = 0x08,
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_DONE = 0x04,
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFFULL = 0x02,
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFEMPTY = 0x01,
+
+/* IH_MUTE field values */
+	HDMI_IH_MUTE_MUTE_WAKEUP_INTERRUPT = 0x2,
+	HDMI_IH_MUTE_MUTE_ALL_INTERRUPT = 0x1,
+
+/* TX_INVID0 field values */
+	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_MASK = 0x80,
+	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_ENABLE = 0x80,
+	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_DISABLE = 0x00,
+	HDMI_TX_INVID0_VIDEO_MAPPING_MASK = 0x1F,
+	HDMI_TX_INVID0_VIDEO_MAPPING_OFFSET = 0,
+
+/* TX_INSTUFFING field values */
+	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_MASK = 0x4,
+	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_ENABLE = 0x4,
+	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_DISABLE = 0x0,
+	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_MASK = 0x2,
+	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_ENABLE = 0x2,
+	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_DISABLE = 0x0,
+	HDMI_TX_INSTUFFING_GYDATA_STUFFING_MASK = 0x1,
+	HDMI_TX_INSTUFFING_GYDATA_STUFFING_ENABLE = 0x1,
+	HDMI_TX_INSTUFFING_GYDATA_STUFFING_DISABLE = 0x0,
+
+/* VP_PR_CD field values */
+	HDMI_VP_PR_CD_COLOR_DEPTH_MASK = 0xF0,
+	HDMI_VP_PR_CD_COLOR_DEPTH_OFFSET = 4,
+	HDMI_VP_PR_CD_DESIRED_PR_FACTOR_MASK = 0x0F,
+	HDMI_VP_PR_CD_DESIRED_PR_FACTOR_OFFSET = 0,
+
+/* VP_STUFF field values */
+	HDMI_VP_STUFF_IDEFAULT_PHASE_MASK = 0x20,
+	HDMI_VP_STUFF_IDEFAULT_PHASE_OFFSET = 5,
+	HDMI_VP_STUFF_IFIX_PP_TO_LAST_MASK = 0x10,
+	HDMI_VP_STUFF_IFIX_PP_TO_LAST_OFFSET = 4,
+	HDMI_VP_STUFF_ICX_GOTO_P0_ST_MASK = 0x8,
+	HDMI_VP_STUFF_ICX_GOTO_P0_ST_OFFSET = 3,
+	HDMI_VP_STUFF_YCC422_STUFFING_MASK = 0x4,
+	HDMI_VP_STUFF_YCC422_STUFFING_STUFFING_MODE = 0x4,
+	HDMI_VP_STUFF_YCC422_STUFFING_DIRECT_MODE = 0x0,
+	HDMI_VP_STUFF_PP_STUFFING_MASK = 0x2,
+	HDMI_VP_STUFF_PP_STUFFING_STUFFING_MODE = 0x2,
+	HDMI_VP_STUFF_PP_STUFFING_DIRECT_MODE = 0x0,
+	HDMI_VP_STUFF_PR_STUFFING_MASK = 0x1,
+	HDMI_VP_STUFF_PR_STUFFING_STUFFING_MODE = 0x1,
+	HDMI_VP_STUFF_PR_STUFFING_DIRECT_MODE = 0x0,
+
+/* VP_CONF field values */
+	HDMI_VP_CONF_BYPASS_EN_MASK = 0x40,
+	HDMI_VP_CONF_BYPASS_EN_ENABLE = 0x40,
+	HDMI_VP_CONF_BYPASS_EN_DISABLE = 0x00,
+	HDMI_VP_CONF_PP_EN_ENMASK = 0x20,
+	HDMI_VP_CONF_PP_EN_ENABLE = 0x20,
+	HDMI_VP_CONF_PP_EN_DISABLE = 0x00,
+	HDMI_VP_CONF_PR_EN_MASK = 0x10,
+	HDMI_VP_CONF_PR_EN_ENABLE = 0x10,
+	HDMI_VP_CONF_PR_EN_DISABLE = 0x00,
+	HDMI_VP_CONF_YCC422_EN_MASK = 0x8,
+	HDMI_VP_CONF_YCC422_EN_ENABLE = 0x8,
+	HDMI_VP_CONF_YCC422_EN_DISABLE = 0x0,
+	HDMI_VP_CONF_BYPASS_SELECT_MASK = 0x4,
+	HDMI_VP_CONF_BYPASS_SELECT_VID_PACKETIZER = 0x4,
+	HDMI_VP_CONF_BYPASS_SELECT_PIX_REPEATER = 0x0,
+	HDMI_VP_CONF_OUTPUT_SELECTOR_MASK = 0x3,
+	HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS = 0x3,
+	HDMI_VP_CONF_OUTPUT_SELECTOR_YCC422 = 0x1,
+	HDMI_VP_CONF_OUTPUT_SELECTOR_PP = 0x0,
+
+/* VP_REMAP field values */
+	HDMI_VP_REMAP_MASK = 0x3,
+	HDMI_VP_REMAP_YCC422_24bit = 0x2,
+	HDMI_VP_REMAP_YCC422_20bit = 0x1,
+	HDMI_VP_REMAP_YCC422_16bit = 0x0,
+
+/* FC_INVIDCONF field values */
+	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_MASK = 0x80,
+	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_ACTIVE = 0x80,
+	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_INACTIVE = 0x00,
+	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_MASK = 0x40,
+	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_HIGH = 0x40,
+	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_LOW = 0x00,
+	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_MASK = 0x20,
+	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_HIGH = 0x20,
+	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_LOW = 0x00,
+	HDMI_FC_INVIDCONF_DE_IN_POLARITY_MASK = 0x10,
+	HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_HIGH = 0x10,
+	HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_LOW = 0x00,
+	HDMI_FC_INVIDCONF_DVI_MODEZ_MASK = 0x8,
+	HDMI_FC_INVIDCONF_DVI_MODEZ_HDMI_MODE = 0x8,
+	HDMI_FC_INVIDCONF_DVI_MODEZ_DVI_MODE = 0x0,
+	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_MASK = 0x2,
+	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_HIGH = 0x2,
+	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_LOW = 0x0,
+	HDMI_FC_INVIDCONF_IN_I_P_MASK = 0x1,
+	HDMI_FC_INVIDCONF_IN_I_P_INTERLACED = 0x1,
+	HDMI_FC_INVIDCONF_IN_I_P_PROGRESSIVE = 0x0,
+
+/* FC_AUDICONF0 field values */
+	HDMI_FC_AUDICONF0_CC_OFFSET = 4,
+	HDMI_FC_AUDICONF0_CC_MASK = 0x70,
+	HDMI_FC_AUDICONF0_CT_OFFSET = 0,
+	HDMI_FC_AUDICONF0_CT_MASK = 0xF,
+
+/* FC_AUDICONF1 field values */
+	HDMI_FC_AUDICONF1_SS_OFFSET = 3,
+	HDMI_FC_AUDICONF1_SS_MASK = 0x18,
+	HDMI_FC_AUDICONF1_SF_OFFSET = 0,
+	HDMI_FC_AUDICONF1_SF_MASK = 0x7,
+
+/* FC_AUDICONF3 field values */
+	HDMI_FC_AUDICONF3_LFEPBL_OFFSET = 5,
+	HDMI_FC_AUDICONF3_LFEPBL_MASK = 0x60,
+	HDMI_FC_AUDICONF3_DM_INH_OFFSET = 4,
+	HDMI_FC_AUDICONF3_DM_INH_MASK = 0x10,
+	HDMI_FC_AUDICONF3_LSV_OFFSET = 0,
+	HDMI_FC_AUDICONF3_LSV_MASK = 0xF,
+
+/* FC_AUDSCHNLS0 field values */
+	HDMI_FC_AUDSCHNLS0_CGMSA_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS0_CGMSA_MASK = 0x30,
+	HDMI_FC_AUDSCHNLS0_COPYRIGHT_OFFSET = 0,
+	HDMI_FC_AUDSCHNLS0_COPYRIGHT_MASK = 0x01,
+
+/* FC_AUDSCHNLS3-6 field values */
+	HDMI_FC_AUDSCHNLS3_OIEC_CH0_OFFSET = 0,
+	HDMI_FC_AUDSCHNLS3_OIEC_CH0_MASK = 0x0f,
+	HDMI_FC_AUDSCHNLS3_OIEC_CH1_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS3_OIEC_CH1_MASK = 0xf0,
+	HDMI_FC_AUDSCHNLS4_OIEC_CH2_OFFSET = 0,
+	HDMI_FC_AUDSCHNLS4_OIEC_CH2_MASK = 0x0f,
+	HDMI_FC_AUDSCHNLS4_OIEC_CH3_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS4_OIEC_CH3_MASK = 0xf0,
+
+	HDMI_FC_AUDSCHNLS5_OIEC_CH0_OFFSET = 0,
+	HDMI_FC_AUDSCHNLS5_OIEC_CH0_MASK = 0x0f,
+	HDMI_FC_AUDSCHNLS5_OIEC_CH1_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS5_OIEC_CH1_MASK = 0xf0,
+	HDMI_FC_AUDSCHNLS6_OIEC_CH2_OFFSET = 0,
+	HDMI_FC_AUDSCHNLS6_OIEC_CH2_MASK = 0x0f,
+	HDMI_FC_AUDSCHNLS6_OIEC_CH3_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS6_OIEC_CH3_MASK = 0xf0,
+
+/* HDMI_FC_AUDSCHNLS7 field values */
+	HDMI_FC_AUDSCHNLS7_ACCURACY_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS7_ACCURACY_MASK = 0x30,
+
+/* HDMI_FC_AUDSCHNLS8 field values */
+	HDMI_FC_AUDSCHNLS8_ORIGSAMPFREQ_MASK = 0xf0,
+	HDMI_FC_AUDSCHNLS8_ORIGSAMPFREQ_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS8_WORDLEGNTH_MASK = 0x0f,
+	HDMI_FC_AUDSCHNLS8_WORDLEGNTH_OFFSET = 0,
+
+/* FC_AUDSCONF field values */
+	HDMI_FC_AUDSCONF_AUD_PACKET_SAMPFIT_MASK = 0xF0,
+	HDMI_FC_AUDSCONF_AUD_PACKET_SAMPFIT_OFFSET = 4,
+	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_MASK = 0x1,
+	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_OFFSET = 0,
+	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_LAYOUT1 = 0x1,
+	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_LAYOUT0 = 0x0,
+
+/* FC_STAT2 field values */
+	HDMI_FC_STAT2_OVERFLOW_MASK = 0x03,
+	HDMI_FC_STAT2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* FC_INT2 field values */
+	HDMI_FC_INT2_OVERFLOW_MASK = 0x03,
+	HDMI_FC_INT2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_FC_INT2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* FC_MASK2 field values */
+	HDMI_FC_MASK2_OVERFLOW_MASK = 0x03,
+	HDMI_FC_MASK2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_FC_MASK2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* FC_PRCONF field values */
+	HDMI_FC_PRCONF_INCOMING_PR_FACTOR_MASK = 0xF0,
+	HDMI_FC_PRCONF_INCOMING_PR_FACTOR_OFFSET = 4,
+	HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_MASK = 0x0F,
+	HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_OFFSET = 0,
+
+/* FC_PACKET_TX_EN field values */
+	HDMI_FC_PACKET_TX_EN_DRM_MASK = 0x80,
+	HDMI_FC_PACKET_TX_EN_DRM_ENABLE = 0x80,
+	HDMI_FC_PACKET_TX_EN_DRM_DISABLE = 0x00,
+
+/* FC_AVICONF0-FC_AVICONF3 field values */
+	HDMI_FC_AVICONF0_PIX_FMT_MASK = 0x03,
+	HDMI_FC_AVICONF0_PIX_FMT_RGB = 0x00,
+	HDMI_FC_AVICONF0_PIX_FMT_YCBCR422 = 0x01,
+	HDMI_FC_AVICONF0_PIX_FMT_YCBCR444 = 0x02,
+	HDMI_FC_AVICONF0_ACTIVE_FMT_MASK = 0x40,
+	HDMI_FC_AVICONF0_ACTIVE_FMT_INFO_PRESENT = 0x40,
+	HDMI_FC_AVICONF0_ACTIVE_FMT_NO_INFO = 0x00,
+	HDMI_FC_AVICONF0_BAR_DATA_MASK = 0x0C,
+	HDMI_FC_AVICONF0_BAR_DATA_NO_DATA = 0x00,
+	HDMI_FC_AVICONF0_BAR_DATA_VERT_BAR = 0x04,
+	HDMI_FC_AVICONF0_BAR_DATA_HORIZ_BAR = 0x08,
+	HDMI_FC_AVICONF0_BAR_DATA_VERT_HORIZ_BAR = 0x0C,
+	HDMI_FC_AVICONF0_SCAN_INFO_MASK = 0x30,
+	HDMI_FC_AVICONF0_SCAN_INFO_OVERSCAN = 0x10,
+	HDMI_FC_AVICONF0_SCAN_INFO_UNDERSCAN = 0x20,
+	HDMI_FC_AVICONF0_SCAN_INFO_NODATA = 0x00,
+
+	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_MASK = 0x0F,
+	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_USE_CODED = 0x08,
+	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_4_3 = 0x09,
+	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_16_9 = 0x0A,
+	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_14_9 = 0x0B,
+	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_MASK = 0x30,
+	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_NO_DATA = 0x00,
+	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_4_3 = 0x10,
+	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_16_9 = 0x20,
+	HDMI_FC_AVICONF1_COLORIMETRY_MASK = 0xC0,
+	HDMI_FC_AVICONF1_COLORIMETRY_NO_DATA = 0x00,
+	HDMI_FC_AVICONF1_COLORIMETRY_SMPTE = 0x40,
+	HDMI_FC_AVICONF1_COLORIMETRY_ITUR = 0x80,
+	HDMI_FC_AVICONF1_COLORIMETRY_EXTENDED_INFO = 0xC0,
+
+	HDMI_FC_AVICONF2_SCALING_MASK = 0x03,
+	HDMI_FC_AVICONF2_SCALING_NONE = 0x00,
+	HDMI_FC_AVICONF2_SCALING_HORIZ = 0x01,
+	HDMI_FC_AVICONF2_SCALING_VERT = 0x02,
+	HDMI_FC_AVICONF2_SCALING_HORIZ_VERT = 0x03,
+	HDMI_FC_AVICONF2_RGB_QUANT_MASK = 0x0C,
+	HDMI_FC_AVICONF2_RGB_QUANT_DEFAULT = 0x00,
+	HDMI_FC_AVICONF2_RGB_QUANT_LIMITED_RANGE = 0x04,
+	HDMI_FC_AVICONF2_RGB_QUANT_FULL_RANGE = 0x08,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_MASK = 0x70,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC601 = 0x00,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC709 = 0x10,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_SYCC601 = 0x20,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_ADOBE_YCC601 = 0x30,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_ADOBE_RGB = 0x40,
+	HDMI_FC_AVICONF2_IT_CONTENT_MASK = 0x80,
+	HDMI_FC_AVICONF2_IT_CONTENT_NO_DATA = 0x00,
+	HDMI_FC_AVICONF2_IT_CONTENT_VALID = 0x80,
+
+	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_MASK = 0x03,
+	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_GRAPHICS = 0x00,
+	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_PHOTO = 0x01,
+	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_CINEMA = 0x02,
+	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_GAME = 0x03,
+	HDMI_FC_AVICONF3_QUANT_RANGE_MASK = 0x0C,
+	HDMI_FC_AVICONF3_QUANT_RANGE_LIMITED = 0x00,
+	HDMI_FC_AVICONF3_QUANT_RANGE_FULL = 0x04,
+
+/* HDMI_FC_GCP */
+	HDMI_FC_GCP_SET_AVMUTE = 0x2,
+	HDMI_FC_GCP_CLEAR_AVMUTE = 0x1,
+
+/* FC_DBGFORCE field values */
+	HDMI_FC_DBGFORCE_FORCEAUDIO = 0x10,
+	HDMI_FC_DBGFORCE_FORCEVIDEO = 0x1,
+
+/* FC_DATAUTO0 field values */
+	HDMI_FC_DATAUTO0_VSD_MASK = 0x08,
+	HDMI_FC_DATAUTO0_VSD_OFFSET = 3,
+
+/* FC_DATAUTO3 field values */
+	HDMI_FC_DATAUTO3_GCP_AUTO = 0x04,
+
+/* PHY_CONF0 field values */
+	HDMI_PHY_CONF0_PDZ_MASK = 0x80,
+	HDMI_PHY_CONF0_PDZ_OFFSET = 7,
+	HDMI_PHY_CONF0_ENTMDS_MASK = 0x40,
+	HDMI_PHY_CONF0_ENTMDS_OFFSET = 6,
+	HDMI_PHY_CONF0_SVSRET_MASK = 0x20,
+	HDMI_PHY_CONF0_SVSRET_OFFSET = 5,
+	HDMI_PHY_CONF0_GEN2_PDDQ_MASK = 0x10,
+	HDMI_PHY_CONF0_GEN2_PDDQ_OFFSET = 4,
+	HDMI_PHY_CONF0_GEN2_TXPWRON_MASK = 0x8,
+	HDMI_PHY_CONF0_GEN2_TXPWRON_OFFSET = 3,
+	HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE_MASK = 0x4,
+	HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE_OFFSET = 2,
+	HDMI_PHY_CONF0_SELDATAENPOL_MASK = 0x2,
+	HDMI_PHY_CONF0_SELDATAENPOL_OFFSET = 1,
+	HDMI_PHY_CONF0_SELDIPIF_MASK = 0x1,
+	HDMI_PHY_CONF0_SELDIPIF_OFFSET = 0,
+
+/* PHY_TST0 field values */
+	HDMI_PHY_TST0_TSTCLR_MASK = 0x20,
+	HDMI_PHY_TST0_TSTCLR_OFFSET = 5,
+	HDMI_PHY_TST0_TSTEN_MASK = 0x10,
+	HDMI_PHY_TST0_TSTEN_OFFSET = 4,
+	HDMI_PHY_TST0_TSTCLK_MASK = 0x1,
+	HDMI_PHY_TST0_TSTCLK_OFFSET = 0,
+
+/* PHY_STAT0 field values */
+	HDMI_PHY_RX_SENSE3 = 0x80,
+	HDMI_PHY_RX_SENSE2 = 0x40,
+	HDMI_PHY_RX_SENSE1 = 0x20,
+	HDMI_PHY_RX_SENSE0 = 0x10,
+	HDMI_PHY_HPD = 0x02,
+	HDMI_PHY_TX_PHY_LOCK = 0x01,
+
+/* PHY_I2CM_SLAVE_ADDR field values */
+	HDMI_PHY_I2CM_SLAVE_ADDR_PHY_GEN2 = 0x69,
+	HDMI_PHY_I2CM_SLAVE_ADDR_HEAC_PHY = 0x49,
+
+/* PHY_I2CM_OPERATION_ADDR field values */
+	HDMI_PHY_I2CM_OPERATION_ADDR_WRITE = 0x10,
+	HDMI_PHY_I2CM_OPERATION_ADDR_READ = 0x1,
+
+/* HDMI_PHY_I2CM_INT_ADDR */
+	HDMI_PHY_I2CM_INT_ADDR_DONE_POL = 0x08,
+	HDMI_PHY_I2CM_INT_ADDR_DONE_MASK = 0x04,
+
+/* HDMI_PHY_I2CM_CTLINT_ADDR */
+	HDMI_PHY_I2CM_CTLINT_ADDR_NAC_POL = 0x80,
+	HDMI_PHY_I2CM_CTLINT_ADDR_NAC_MASK = 0x40,
+	HDMI_PHY_I2CM_CTLINT_ADDR_ARBITRATION_POL = 0x08,
+	HDMI_PHY_I2CM_CTLINT_ADDR_ARBITRATION_MASK = 0x04,
+
+/* AUD_CONF0 field values */
+	HDMI_AUD_CONF0_SW_RESET = 0x80,
+	HDMI_AUD_CONF0_I2S_SELECT = 0x20,
+	HDMI_AUD_CONF0_I2S_EN3 = 0x08,
+	HDMI_AUD_CONF0_I2S_EN2 = 0x04,
+	HDMI_AUD_CONF0_I2S_EN1 = 0x02,
+	HDMI_AUD_CONF0_I2S_EN0 = 0x01,
+
+/* AUD_CONF1 field values */
+	HDMI_AUD_CONF1_MODE_I2S = 0x00,
+	HDMI_AUD_CONF1_MODE_RIGHT_J = 0x20,
+	HDMI_AUD_CONF1_MODE_LEFT_J = 0x40,
+	HDMI_AUD_CONF1_MODE_BURST_1 = 0x60,
+	HDMI_AUD_CONF1_MODE_BURST_2 = 0x80,
+	HDMI_AUD_CONF1_WIDTH_16 = 0x10,
+	HDMI_AUD_CONF1_WIDTH_24 = 0x18,
+
+/* AUD_CTS3 field values */
+	HDMI_AUD_CTS3_N_SHIFT_OFFSET = 5,
+	HDMI_AUD_CTS3_N_SHIFT_MASK = 0xe0,
+	HDMI_AUD_CTS3_N_SHIFT_1 = 0,
+	HDMI_AUD_CTS3_N_SHIFT_16 = 0x20,
+	HDMI_AUD_CTS3_N_SHIFT_32 = 0x40,
+	HDMI_AUD_CTS3_N_SHIFT_64 = 0x60,
+	HDMI_AUD_CTS3_N_SHIFT_128 = 0x80,
+	HDMI_AUD_CTS3_N_SHIFT_256 = 0xa0,
+	/* note that the CTS3 MANUAL bit has been removed
+	   from our part. Can't set it, will read as 0. */
+	HDMI_AUD_CTS3_CTS_MANUAL = 0x10,
+	HDMI_AUD_CTS3_AUDCTS19_16_MASK = 0x0f,
+
+/* HDMI_AUD_INPUTCLKFS field values */
+	HDMI_AUD_INPUTCLKFS_128FS = 0,
+	HDMI_AUD_INPUTCLKFS_256FS = 1,
+	HDMI_AUD_INPUTCLKFS_512FS = 2,
+	HDMI_AUD_INPUTCLKFS_64FS = 4,
+
+/* AHB_DMA_CONF0 field values */
+	HDMI_AHB_DMA_CONF0_SW_FIFO_RST_OFFSET = 7,
+	HDMI_AHB_DMA_CONF0_SW_FIFO_RST_MASK = 0x80,
+	HDMI_AHB_DMA_CONF0_HBR = 0x10,
+	HDMI_AHB_DMA_CONF0_EN_HLOCK_OFFSET = 3,
+	HDMI_AHB_DMA_CONF0_EN_HLOCK_MASK = 0x08,
+	HDMI_AHB_DMA_CONF0_INCR_TYPE_OFFSET = 1,
+	HDMI_AHB_DMA_CONF0_INCR_TYPE_MASK = 0x06,
+	HDMI_AHB_DMA_CONF0_INCR4 = 0x0,
+	HDMI_AHB_DMA_CONF0_INCR8 = 0x2,
+	HDMI_AHB_DMA_CONF0_INCR16 = 0x4,
+	HDMI_AHB_DMA_CONF0_BURST_MODE = 0x1,
+
+/* HDMI_AHB_DMA_START field values */
+	HDMI_AHB_DMA_START_START_OFFSET = 0,
+	HDMI_AHB_DMA_START_START_MASK = 0x01,
+
+/* HDMI_AHB_DMA_STOP field values */
+	HDMI_AHB_DMA_STOP_STOP_OFFSET = 0,
+	HDMI_AHB_DMA_STOP_STOP_MASK = 0x01,
+
+/* AHB_DMA_STAT, AHB_DMA_INT, AHB_DMA_MASK, AHB_DMA_POL field values */
+	HDMI_AHB_DMA_DONE = 0x80,
+	HDMI_AHB_DMA_RETRY_SPLIT = 0x40,
+	HDMI_AHB_DMA_LOSTOWNERSHIP = 0x20,
+	HDMI_AHB_DMA_ERROR = 0x10,
+	HDMI_AHB_DMA_FIFO_THREMPTY = 0x04,
+	HDMI_AHB_DMA_FIFO_FULL = 0x02,
+	HDMI_AHB_DMA_FIFO_EMPTY = 0x01,
+
+/* AHB_DMA_BUFFSTAT, AHB_DMA_BUFFINT,AHB_DMA_BUFFMASK,AHB_DMA_BUFFPOL values */
+	HDMI_AHB_DMA_BUFFSTAT_FULL = 0x02,
+	HDMI_AHB_DMA_BUFFSTAT_EMPTY = 0x01,
+
+/* MC_CLKDIS field values */
+	HDMI_MC_CLKDIS_HDCPCLK_DISABLE = 0x40,
+	HDMI_MC_CLKDIS_CECCLK_DISABLE = 0x20,
+	HDMI_MC_CLKDIS_CSCCLK_DISABLE = 0x10,
+	HDMI_MC_CLKDIS_AUDCLK_DISABLE = 0x8,
+	HDMI_MC_CLKDIS_PREPCLK_DISABLE = 0x4,
+	HDMI_MC_CLKDIS_TMDSCLK_DISABLE = 0x2,
+	HDMI_MC_CLKDIS_PIXELCLK_DISABLE = 0x1,
+	HDMI_MC_CLKDIS_PIXELCLK_MASK = 0x1,
+	HDMI_MC_CLKDIS_PIXELCLK_ENABLE = 0,
+
+/* MC_SWRSTZ field values */
+	HDMI_MC_SWRSTZ_I2SSWRST_REQ = 0x08,
+	HDMI_MC_SWRSTZ_TMDSSWRST_REQ = 0x02,
+
+/* MC_FLOWCTRL field values */
+	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_MASK = 0x1,
+	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_IN_PATH = 0x1,
+	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_BYPASS = 0x0,
+
+/* MC_PHYRSTZ field values */
+	HDMI_MC_PHYRSTZ_PHYRSTZ = 0x01,
+
+/* MC_HEACPHY_RST field values */
+	HDMI_MC_HEACPHY_RST_ASSERT = 0x1,
+	HDMI_MC_HEACPHY_RST_DEASSERT = 0x0,
+
+/* CSC_CFG field values */
+	HDMI_CSC_CFG_INTMODE_MASK = 0x30,
+	HDMI_CSC_CFG_INTMODE_OFFSET = 4,
+	HDMI_CSC_CFG_INTMODE_DISABLE = 0x00,
+	HDMI_CSC_CFG_INTMODE_CHROMA_INT_FORMULA1 = 0x10,
+	HDMI_CSC_CFG_INTMODE_CHROMA_INT_FORMULA2 = 0x20,
+	HDMI_CSC_CFG_DECMODE_MASK = 0x3,
+	HDMI_CSC_CFG_DECMODE_OFFSET = 0,
+	HDMI_CSC_CFG_DECMODE_DISABLE = 0x0,
+	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA1 = 0x1,
+	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA2 = 0x2,
+	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA3 = 0x3,
+
+/* CSC_SCALE field values */
+	HDMI_CSC_SCALE_CSC_COLORDE_PTH_MASK = 0xF0,
+	HDMI_CSC_SCALE_CSC_COLORDE_PTH_24BPP = 0x00,
+	HDMI_CSC_SCALE_CSC_COLORDE_PTH_30BPP = 0x50,
+	HDMI_CSC_SCALE_CSC_COLORDE_PTH_36BPP = 0x60,
+	HDMI_CSC_SCALE_CSC_COLORDE_PTH_48BPP = 0x70,
+	HDMI_CSC_SCALE_CSCSCALE_MASK = 0x03,
+
+/* A_HDCPCFG0 field values */
+	HDMI_A_HDCPCFG0_ELVENA_MASK = 0x80,
+	HDMI_A_HDCPCFG0_ELVENA_ENABLE = 0x80,
+	HDMI_A_HDCPCFG0_ELVENA_DISABLE = 0x00,
+	HDMI_A_HDCPCFG0_I2CFASTMODE_MASK = 0x40,
+	HDMI_A_HDCPCFG0_I2CFASTMODE_ENABLE = 0x40,
+	HDMI_A_HDCPCFG0_I2CFASTMODE_DISABLE = 0x00,
+	HDMI_A_HDCPCFG0_BYPENCRYPTION_MASK = 0x20,
+	HDMI_A_HDCPCFG0_BYPENCRYPTION_ENABLE = 0x20,
+	HDMI_A_HDCPCFG0_BYPENCRYPTION_DISABLE = 0x00,
+	HDMI_A_HDCPCFG0_SYNCRICHECK_MASK = 0x10,
+	HDMI_A_HDCPCFG0_SYNCRICHECK_ENABLE = 0x10,
+	HDMI_A_HDCPCFG0_SYNCRICHECK_DISABLE = 0x00,
+	HDMI_A_HDCPCFG0_AVMUTE_MASK = 0x8,
+	HDMI_A_HDCPCFG0_AVMUTE_ENABLE = 0x8,
+	HDMI_A_HDCPCFG0_AVMUTE_DISABLE = 0x0,
+	HDMI_A_HDCPCFG0_RXDETECT_MASK = 0x4,
+	HDMI_A_HDCPCFG0_RXDETECT_ENABLE = 0x4,
+	HDMI_A_HDCPCFG0_RXDETECT_DISABLE = 0x0,
+	HDMI_A_HDCPCFG0_EN11FEATURE_MASK = 0x2,
+	HDMI_A_HDCPCFG0_EN11FEATURE_ENABLE = 0x2,
+	HDMI_A_HDCPCFG0_EN11FEATURE_DISABLE = 0x0,
+	HDMI_A_HDCPCFG0_HDMIDVI_MASK = 0x1,
+	HDMI_A_HDCPCFG0_HDMIDVI_HDMI = 0x1,
+	HDMI_A_HDCPCFG0_HDMIDVI_DVI = 0x0,
+
+/* A_HDCPCFG1 field values */
+	HDMI_A_HDCPCFG1_DISSHA1CHECK_MASK = 0x8,
+	HDMI_A_HDCPCFG1_DISSHA1CHECK_DISABLE = 0x8,
+	HDMI_A_HDCPCFG1_DISSHA1CHECK_ENABLE = 0x0,
+	HDMI_A_HDCPCFG1_PH2UPSHFTENC_MASK = 0x4,
+	HDMI_A_HDCPCFG1_PH2UPSHFTENC_ENABLE = 0x4,
+	HDMI_A_HDCPCFG1_PH2UPSHFTENC_DISABLE = 0x0,
+	HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_MASK = 0x2,
+	HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_DISABLE = 0x2,
+	HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_ENABLE = 0x0,
+	HDMI_A_HDCPCFG1_SWRESET_MASK = 0x1,
+	HDMI_A_HDCPCFG1_SWRESET_ASSERT = 0x0,
+
+/* A_VIDPOLCFG field values */
+	HDMI_A_VIDPOLCFG_UNENCRYPTCONF_MASK = 0x60,
+	HDMI_A_VIDPOLCFG_UNENCRYPTCONF_OFFSET = 5,
+	HDMI_A_VIDPOLCFG_DATAENPOL_MASK = 0x10,
+	HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_HIGH = 0x10,
+	HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_LOW = 0x0,
+	HDMI_A_VIDPOLCFG_VSYNCPOL_MASK = 0x8,
+	HDMI_A_VIDPOLCFG_VSYNCPOL_ACTIVE_HIGH = 0x8,
+	HDMI_A_VIDPOLCFG_VSYNCPOL_ACTIVE_LOW = 0x0,
+	HDMI_A_VIDPOLCFG_HSYNCPOL_MASK = 0x2,
+	HDMI_A_VIDPOLCFG_HSYNCPOL_ACTIVE_HIGH = 0x2,
+	HDMI_A_VIDPOLCFG_HSYNCPOL_ACTIVE_LOW = 0x0,
+
+/* I2CM_OPERATION field values */
+	HDMI_I2CM_OPERATION_BUSCLEAR = 0x20,
+	HDMI_I2CM_OPERATION_WRITE = 0x10,
+	HDMI_I2CM_OPERATION_READ_EXT = 0x2,
+	HDMI_I2CM_OPERATION_READ = 0x1,
+
+/* I2CM_INT field values */
+	HDMI_I2CM_INT_DONE_POL = 0x8,
+	HDMI_I2CM_INT_DONE_MASK = 0x4,
+
+/* I2CM_CTLINT field values */
+	HDMI_I2CM_CTLINT_NAC_POL = 0x80,
+	HDMI_I2CM_CTLINT_NAC_MASK = 0x40,
+	HDMI_I2CM_CTLINT_ARB_POL = 0x8,
+	HDMI_I2CM_CTLINT_ARB_MASK = 0x4,
+};
+
+/*
+ * HDMI 3D TX PHY registers
+ */
+#define HDMI_3D_TX_PHY_PWRCTRL			0x00
+#define HDMI_3D_TX_PHY_SERDIVCTRL		0x01
+#define HDMI_3D_TX_PHY_SERCKCTRL		0x02
+#define HDMI_3D_TX_PHY_SERCKKILLCTRL		0x03
+#define HDMI_3D_TX_PHY_TXRESCTRL		0x04
+#define HDMI_3D_TX_PHY_CKCALCTRL		0x05
+#define HDMI_3D_TX_PHY_CPCE_CTRL		0x06
+#define HDMI_3D_TX_PHY_TXCLKMEASCTRL		0x07
+#define HDMI_3D_TX_PHY_TXMEASCTRL		0x08
+#define HDMI_3D_TX_PHY_CKSYMTXCTRL		0x09
+#define HDMI_3D_TX_PHY_CMPSEQCTRL		0x0a
+#define HDMI_3D_TX_PHY_CMPPWRCTRL		0x0b
+#define HDMI_3D_TX_PHY_CMPMODECTRL		0x0c
+#define HDMI_3D_TX_PHY_MEASCTRL			0x0d
+#define HDMI_3D_TX_PHY_VLEVCTRL			0x0e
+#define HDMI_3D_TX_PHY_D2ACTRL			0x0f
+#define HDMI_3D_TX_PHY_CURRCTRL			0x10
+#define HDMI_3D_TX_PHY_DRVANACTRL		0x11
+#define HDMI_3D_TX_PHY_PLLMEASCTRL		0x12
+#define HDMI_3D_TX_PHY_PLLPHBYCTRL		0x13
+#define HDMI_3D_TX_PHY_GRP_CTRL			0x14
+#define HDMI_3D_TX_PHY_GMPCTRL			0x15
+#define HDMI_3D_TX_PHY_MPLLMEASCTRL		0x16
+#define HDMI_3D_TX_PHY_MSM_CTRL			0x17
+#define HDMI_3D_TX_PHY_SCRPB_STATUS		0x18
+#define HDMI_3D_TX_PHY_TXTERM			0x19
+#define HDMI_3D_TX_PHY_PTRPT_ENBL		0x1a
+#define HDMI_3D_TX_PHY_PATTERNGEN		0x1b
+#define HDMI_3D_TX_PHY_SDCAP_MODE		0x1c
+#define HDMI_3D_TX_PHY_SCOPEMODE		0x1d
+#define HDMI_3D_TX_PHY_DIGTXMODE		0x1e
+#define HDMI_3D_TX_PHY_STR_STATUS		0x1f
+#define HDMI_3D_TX_PHY_SCOPECNT0		0x20
+#define HDMI_3D_TX_PHY_SCOPECNT1		0x21
+#define HDMI_3D_TX_PHY_SCOPECNT2		0x22
+#define HDMI_3D_TX_PHY_SCOPECNTCLK		0x23
+#define HDMI_3D_TX_PHY_SCOPESAMPLE		0x24
+#define HDMI_3D_TX_PHY_SCOPECNTMSB01		0x25
+#define HDMI_3D_TX_PHY_SCOPECNTMSB2CK		0x26
+
+/* HDMI_3D_TX_PHY_CKCALCTRL values */
+#define HDMI_3D_TX_PHY_CKCALCTRL_OVERRIDE		BIT(15)
+
+/* HDMI_3D_TX_PHY_MSM_CTRL values */
+#define HDMI_3D_TX_PHY_MSM_CTRL_MPLL_PH_SEL_CK		BIT(13)
+#define HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_CLK_REF_MPLL	(0 << 1)
+#define HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_OFF		(1 << 1)
+#define HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_PCLK		(2 << 1)
+#define HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_FB_CLK		(3 << 1)
+#define HDMI_3D_TX_PHY_MSM_CTRL_SCOPE_CK_SEL		BIT(0)
+
+/* HDMI_3D_TX_PHY_PTRPT_ENBL values */
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_OVERRIDE		BIT(15)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_PG_SKIP_BIT2		BIT(8)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_PG_SKIP_BIT1		BIT(7)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_PG_SKIP_BIT0		BIT(6)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_CK_REF_ENB		BIT(5)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_RCAL_ENB		BIT(4)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_TX_CLK_ALIGN_ENB	BIT(3)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_TX_READY		BIT(2)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_CKO_WORD_ENB		BIT(1)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_REFCLK_ENB		BIT(0)
+
+struct dw_hdmi;
+
+struct dw_hdmi_property_ops {
+	void (*attatch_properties)(struct drm_connector *connector,
+				   unsigned int color, int version, void *data);
+	void (*destroy_properties)(struct drm_connector *connector, void *data);
+	int (*set_property)(struct drm_connector *connector,
+			    struct drm_connector_state *state,
+			    struct drm_property *property, u64 val, void *data);
+	int (*get_property)(struct drm_connector *connector,
+			    const struct drm_connector_state *state,
+			    struct drm_property *property, u64 *val,
+			    void *data);
+};
+
+enum supported_eotf_type {
+	TRADITIONAL_GAMMA_SDR = 0,
+	TRADITIONAL_GAMMA_HDR,
+	SMPTE_ST2084,
+	HLG,
+	FUTURE_EOTF
+};
+
+void dw_hdmi_suspend(struct dw_hdmi *hdmi);
+void dw_hdmi_enable_video(struct dw_hdmi *hdmi);
+void dw_hdmi_disable_video(struct dw_hdmi *hdmi);
+#endif /* __DW_HDMI_H__ */
diff --git a/drivers/gpu/drm/eswin/dw_hdmi.h b/drivers/gpu/drm/eswin/dw_hdmi.h
deleted file mode 100644
index 6281fd8bfc53..000000000000
--- a/drivers/gpu/drm/eswin/dw_hdmi.h
+++ /dev/null
@@ -1,1408 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- * Copyright (C) 2011 Freescale Semiconductor, Inc.
- */
-
-#ifndef __DW_HDMI_H__
-#define __DW_HDMI_H__
-
-#include <sound/hdmi-codec.h>
-#include <drm/drm_property.h>
-
-extern struct platform_driver dw_hdmi_eswin_pltfm_driver;
-extern struct platform_driver snd_dw_hdmi_driver;
-extern struct platform_driver dw_hdmi_cec_driver;
-extern struct platform_driver dw_hdmi_hdcp_driver;
-extern struct platform_driver dw_hdmi_hdcp2_driver;
-
-/* Identification Registers */
-#define HDMI_DESIGN_ID 0x0000
-#define HDMI_REVISION_ID 0x0001
-#define HDMI_PRODUCT_ID0 0x0002
-#define HDMI_PRODUCT_ID1 0x0003
-#define HDMI_CONFIG0_ID 0x0004
-#define HDMI_CONFIG1_ID 0x0005
-#define HDMI_CONFIG2_ID 0x0006
-#define HDMI_CONFIG3_ID 0x0007
-
-/* Interrupt Registers */
-#define HDMI_IH_FC_STAT0 0x0100
-#define HDMI_IH_FC_STAT1 0x0101
-#define HDMI_IH_FC_STAT2 0x0102
-#define HDMI_IH_AS_STAT0 0x0103
-#define HDMI_IH_PHY_STAT0 0x0104
-#define HDMI_IH_I2CM_STAT0 0x0105
-#define HDMI_IH_CEC_STAT0 0x0106
-#define HDMI_IH_VP_STAT0 0x0107
-#define HDMI_IH_I2CMPHY_STAT0 0x0108
-#define HDMI_IH_AHBDMAAUD_STAT0 0x0109
-
-#define HDMI_IH_MUTE_FC_STAT0 0x0180
-#define HDMI_IH_MUTE_FC_STAT1 0x0181
-#define HDMI_IH_MUTE_FC_STAT2 0x0182
-#define HDMI_IH_MUTE_AS_STAT0 0x0183
-#define HDMI_IH_MUTE_PHY_STAT0 0x0184
-#define HDMI_IH_MUTE_I2CM_STAT0 0x0185
-#define HDMI_IH_MUTE_CEC_STAT0 0x0186
-#define HDMI_IH_MUTE_VP_STAT0 0x0187
-#define HDMI_IH_MUTE_I2CMPHY_STAT0 0x0188
-#define HDMI_IH_MUTE_AHBDMAAUD_STAT0 0x0189
-#define HDMI_IH_MUTE 0x01FF
-
-/* Video Sample Registers */
-#define HDMI_TX_INVID0 0x0200
-#define HDMI_TX_INSTUFFING 0x0201
-#define HDMI_TX_GYDATA0 0x0202
-#define HDMI_TX_GYDATA1 0x0203
-#define HDMI_TX_RCRDATA0 0x0204
-#define HDMI_TX_RCRDATA1 0x0205
-#define HDMI_TX_BCBDATA0 0x0206
-#define HDMI_TX_BCBDATA1 0x0207
-
-/* Video Packetizer Registers */
-#define HDMI_VP_STATUS 0x0800
-#define HDMI_VP_PR_CD 0x0801
-#define HDMI_VP_STUFF 0x0802
-#define HDMI_VP_REMAP 0x0803
-#define HDMI_VP_CONF 0x0804
-#define HDMI_VP_STAT 0x0805
-#define HDMI_VP_INT 0x0806
-#define HDMI_VP_MASK 0x0807
-#define HDMI_VP_POL 0x0808
-
-/* Frame Composer Registers */
-#define HDMI_FC_INVIDCONF 0x1000
-#define HDMI_FC_INHACTV0 0x1001
-#define HDMI_FC_INHACTV1 0x1002
-#define HDMI_FC_INHBLANK0 0x1003
-#define HDMI_FC_INHBLANK1 0x1004
-#define HDMI_FC_INVACTV0 0x1005
-#define HDMI_FC_INVACTV1 0x1006
-#define HDMI_FC_INVBLANK 0x1007
-#define HDMI_FC_HSYNCINDELAY0 0x1008
-#define HDMI_FC_HSYNCINDELAY1 0x1009
-#define HDMI_FC_HSYNCINWIDTH0 0x100A
-#define HDMI_FC_HSYNCINWIDTH1 0x100B
-#define HDMI_FC_VSYNCINDELAY 0x100C
-#define HDMI_FC_VSYNCINWIDTH 0x100D
-#define HDMI_FC_INFREQ0 0x100E
-#define HDMI_FC_INFREQ1 0x100F
-#define HDMI_FC_INFREQ2 0x1010
-#define HDMI_FC_CTRLDUR 0x1011
-#define HDMI_FC_EXCTRLDUR 0x1012
-#define HDMI_FC_EXCTRLSPAC 0x1013
-#define HDMI_FC_CH0PREAM 0x1014
-#define HDMI_FC_CH1PREAM 0x1015
-#define HDMI_FC_CH2PREAM 0x1016
-#define HDMI_FC_AVICONF3 0x1017
-#define HDMI_FC_GCP 0x1018
-#define HDMI_FC_AVICONF0 0x1019
-#define HDMI_FC_AVICONF1 0x101A
-#define HDMI_FC_AVICONF2 0x101B
-#define HDMI_FC_AVIVID 0x101C
-#define HDMI_FC_AVIETB0 0x101D
-#define HDMI_FC_AVIETB1 0x101E
-#define HDMI_FC_AVISBB0 0x101F
-#define HDMI_FC_AVISBB1 0x1020
-#define HDMI_FC_AVIELB0 0x1021
-#define HDMI_FC_AVIELB1 0x1022
-#define HDMI_FC_AVISRB0 0x1023
-#define HDMI_FC_AVISRB1 0x1024
-#define HDMI_FC_AUDICONF0 0x1025
-#define HDMI_FC_AUDICONF1 0x1026
-#define HDMI_FC_AUDICONF2 0x1027
-#define HDMI_FC_AUDICONF3 0x1028
-#define HDMI_FC_VSDIEEEID0 0x1029
-#define HDMI_FC_VSDSIZE 0x102A
-#define HDMI_FC_VSDIEEEID1 0x1030
-#define HDMI_FC_VSDIEEEID2 0x1031
-#define HDMI_FC_VSDPAYLOAD0 0x1032
-#define HDMI_FC_VSDPAYLOAD1 0x1033
-#define HDMI_FC_VSDPAYLOAD2 0x1034
-#define HDMI_FC_VSDPAYLOAD3 0x1035
-#define HDMI_FC_VSDPAYLOAD4 0x1036
-#define HDMI_FC_VSDPAYLOAD5 0x1037
-#define HDMI_FC_VSDPAYLOAD6 0x1038
-#define HDMI_FC_VSDPAYLOAD7 0x1039
-#define HDMI_FC_VSDPAYLOAD8 0x103A
-#define HDMI_FC_VSDPAYLOAD9 0x103B
-#define HDMI_FC_VSDPAYLOAD10 0x103C
-#define HDMI_FC_VSDPAYLOAD11 0x103D
-#define HDMI_FC_VSDPAYLOAD12 0x103E
-#define HDMI_FC_VSDPAYLOAD13 0x103F
-#define HDMI_FC_VSDPAYLOAD14 0x1040
-#define HDMI_FC_VSDPAYLOAD15 0x1041
-#define HDMI_FC_VSDPAYLOAD16 0x1042
-#define HDMI_FC_VSDPAYLOAD17 0x1043
-#define HDMI_FC_VSDPAYLOAD18 0x1044
-#define HDMI_FC_VSDPAYLOAD19 0x1045
-#define HDMI_FC_VSDPAYLOAD20 0x1046
-#define HDMI_FC_VSDPAYLOAD21 0x1047
-#define HDMI_FC_VSDPAYLOAD22 0x1048
-#define HDMI_FC_VSDPAYLOAD23 0x1049
-#define HDMI_FC_SPDVENDORNAME0 0x104A
-#define HDMI_FC_SPDVENDORNAME1 0x104B
-#define HDMI_FC_SPDVENDORNAME2 0x104C
-#define HDMI_FC_SPDVENDORNAME3 0x104D
-#define HDMI_FC_SPDVENDORNAME4 0x104E
-#define HDMI_FC_SPDVENDORNAME5 0x104F
-#define HDMI_FC_SPDVENDORNAME6 0x1050
-#define HDMI_FC_SPDVENDORNAME7 0x1051
-#define HDMI_FC_SDPPRODUCTNAME0 0x1052
-#define HDMI_FC_SDPPRODUCTNAME1 0x1053
-#define HDMI_FC_SDPPRODUCTNAME2 0x1054
-#define HDMI_FC_SDPPRODUCTNAME3 0x1055
-#define HDMI_FC_SDPPRODUCTNAME4 0x1056
-#define HDMI_FC_SDPPRODUCTNAME5 0x1057
-#define HDMI_FC_SDPPRODUCTNAME6 0x1058
-#define HDMI_FC_SDPPRODUCTNAME7 0x1059
-#define HDMI_FC_SDPPRODUCTNAME8 0x105A
-#define HDMI_FC_SDPPRODUCTNAME9 0x105B
-#define HDMI_FC_SDPPRODUCTNAME10 0x105C
-#define HDMI_FC_SDPPRODUCTNAME11 0x105D
-#define HDMI_FC_SDPPRODUCTNAME12 0x105E
-#define HDMI_FC_SDPPRODUCTNAME13 0x105F
-#define HDMI_FC_SDPPRODUCTNAME14 0x1060
-#define HDMI_FC_SPDPRODUCTNAME15 0x1061
-#define HDMI_FC_SPDDEVICEINF 0x1062
-#define HDMI_FC_AUDSCONF 0x1063
-#define HDMI_FC_AUDSSTAT 0x1064
-#define HDMI_FC_AUDSCHNLS7 0x106e
-#define HDMI_FC_AUDSCHNLS8 0x106f
-#define HDMI_FC_DATACH0FILL 0x1070
-#define HDMI_FC_DATACH1FILL 0x1071
-#define HDMI_FC_DATACH2FILL 0x1072
-#define HDMI_FC_CTRLQHIGH 0x1073
-#define HDMI_FC_CTRLQLOW 0x1074
-#define HDMI_FC_ACP0 0x1075
-#define HDMI_FC_ACP28 0x1076
-#define HDMI_FC_ACP27 0x1077
-#define HDMI_FC_ACP26 0x1078
-#define HDMI_FC_ACP25 0x1079
-#define HDMI_FC_ACP24 0x107A
-#define HDMI_FC_ACP23 0x107B
-#define HDMI_FC_ACP22 0x107C
-#define HDMI_FC_ACP21 0x107D
-#define HDMI_FC_ACP20 0x107E
-#define HDMI_FC_ACP19 0x107F
-#define HDMI_FC_ACP18 0x1080
-#define HDMI_FC_ACP17 0x1081
-#define HDMI_FC_ACP16 0x1082
-#define HDMI_FC_ACP15 0x1083
-#define HDMI_FC_ACP14 0x1084
-#define HDMI_FC_ACP13 0x1085
-#define HDMI_FC_ACP12 0x1086
-#define HDMI_FC_ACP11 0x1087
-#define HDMI_FC_ACP10 0x1088
-#define HDMI_FC_ACP9 0x1089
-#define HDMI_FC_ACP8 0x108A
-#define HDMI_FC_ACP7 0x108B
-#define HDMI_FC_ACP6 0x108C
-#define HDMI_FC_ACP5 0x108D
-#define HDMI_FC_ACP4 0x108E
-#define HDMI_FC_ACP3 0x108F
-#define HDMI_FC_ACP2 0x1090
-#define HDMI_FC_ACP1 0x1091
-#define HDMI_FC_ISCR1_0 0x1092
-#define HDMI_FC_ISCR1_16 0x1093
-#define HDMI_FC_ISCR1_15 0x1094
-#define HDMI_FC_ISCR1_14 0x1095
-#define HDMI_FC_ISCR1_13 0x1096
-#define HDMI_FC_ISCR1_12 0x1097
-#define HDMI_FC_ISCR1_11 0x1098
-#define HDMI_FC_ISCR1_10 0x1099
-#define HDMI_FC_ISCR1_9 0x109A
-#define HDMI_FC_ISCR1_8 0x109B
-#define HDMI_FC_ISCR1_7 0x109C
-#define HDMI_FC_ISCR1_6 0x109D
-#define HDMI_FC_ISCR1_5 0x109E
-#define HDMI_FC_ISCR1_4 0x109F
-#define HDMI_FC_ISCR1_3 0x10A0
-#define HDMI_FC_ISCR1_2 0x10A1
-#define HDMI_FC_ISCR1_1 0x10A2
-#define HDMI_FC_ISCR2_15 0x10A3
-#define HDMI_FC_ISCR2_14 0x10A4
-#define HDMI_FC_ISCR2_13 0x10A5
-#define HDMI_FC_ISCR2_12 0x10A6
-#define HDMI_FC_ISCR2_11 0x10A7
-#define HDMI_FC_ISCR2_10 0x10A8
-#define HDMI_FC_ISCR2_9 0x10A9
-#define HDMI_FC_ISCR2_8 0x10AA
-#define HDMI_FC_ISCR2_7 0x10AB
-#define HDMI_FC_ISCR2_6 0x10AC
-#define HDMI_FC_ISCR2_5 0x10AD
-#define HDMI_FC_ISCR2_4 0x10AE
-#define HDMI_FC_ISCR2_3 0x10AF
-#define HDMI_FC_ISCR2_2 0x10B0
-#define HDMI_FC_ISCR2_1 0x10B1
-#define HDMI_FC_ISCR2_0 0x10B2
-#define HDMI_FC_DATAUTO0 0x10B3
-#define HDMI_FC_DATAUTO1 0x10B4
-#define HDMI_FC_DATAUTO2 0x10B5
-#define HDMI_FC_DATMAN 0x10B6
-#define HDMI_FC_DATAUTO3 0x10B7
-#define HDMI_FC_RDRB0 0x10B8
-#define HDMI_FC_RDRB1 0x10B9
-#define HDMI_FC_RDRB2 0x10BA
-#define HDMI_FC_RDRB3 0x10BB
-#define HDMI_FC_RDRB4 0x10BC
-#define HDMI_FC_RDRB5 0x10BD
-#define HDMI_FC_RDRB6 0x10BE
-#define HDMI_FC_RDRB7 0x10BF
-#define HDMI_FC_STAT0 0x10D0
-#define HDMI_FC_INT0 0x10D1
-#define HDMI_FC_MASK0 0x10D2
-#define HDMI_FC_POL0 0x10D3
-#define HDMI_FC_STAT1 0x10D4
-#define HDMI_FC_INT1 0x10D5
-#define HDMI_FC_MASK1 0x10D6
-#define HDMI_FC_POL1 0x10D7
-#define HDMI_FC_STAT2 0x10D8
-#define HDMI_FC_INT2 0x10D9
-#define HDMI_FC_MASK2 0x10DA
-#define HDMI_FC_POL2 0x10DB
-#define HDMI_FC_PRCONF 0x10E0
-#define HDMI_FC_SCRAMBLER_CTRL 0x10E1
-#define HDMI_FC_PACKET_TX_EN 0x10E3
-
-#define HDMI_FC_GMD_STAT 0x1100
-#define HDMI_FC_GMD_EN 0x1101
-#define HDMI_FC_GMD_UP 0x1102
-#define HDMI_FC_GMD_CONF 0x1103
-#define HDMI_FC_GMD_HB 0x1104
-#define HDMI_FC_GMD_PB0 0x1105
-#define HDMI_FC_GMD_PB1 0x1106
-#define HDMI_FC_GMD_PB2 0x1107
-#define HDMI_FC_GMD_PB3 0x1108
-#define HDMI_FC_GMD_PB4 0x1109
-#define HDMI_FC_GMD_PB5 0x110A
-#define HDMI_FC_GMD_PB6 0x110B
-#define HDMI_FC_GMD_PB7 0x110C
-#define HDMI_FC_GMD_PB8 0x110D
-#define HDMI_FC_GMD_PB9 0x110E
-#define HDMI_FC_GMD_PB10 0x110F
-#define HDMI_FC_GMD_PB11 0x1110
-#define HDMI_FC_GMD_PB12 0x1111
-#define HDMI_FC_GMD_PB13 0x1112
-#define HDMI_FC_GMD_PB14 0x1113
-#define HDMI_FC_GMD_PB15 0x1114
-#define HDMI_FC_GMD_PB16 0x1115
-#define HDMI_FC_GMD_PB17 0x1116
-#define HDMI_FC_GMD_PB18 0x1117
-#define HDMI_FC_GMD_PB19 0x1118
-#define HDMI_FC_GMD_PB20 0x1119
-#define HDMI_FC_GMD_PB21 0x111A
-#define HDMI_FC_GMD_PB22 0x111B
-#define HDMI_FC_GMD_PB23 0x111C
-#define HDMI_FC_GMD_PB24 0x111D
-#define HDMI_FC_GMD_PB25 0x111E
-#define HDMI_FC_GMD_PB26 0x111F
-#define HDMI_FC_GMD_PB27 0x1120
-
-#define HDMI_FC_DRM_UP 0x1167
-#define HDMI_FC_DRM_HB0 0x1168
-#define HDMI_FC_DRM_HB1 0x1169
-#define HDMI_FC_DRM_PB0 0x116A
-#define HDMI_FC_DRM_PB1 0x116B
-#define HDMI_FC_DRM_PB2 0x116C
-#define HDMI_FC_DRM_PB3 0x116D
-#define HDMI_FC_DRM_PB4 0x116E
-#define HDMI_FC_DRM_PB5 0x116F
-#define HDMI_FC_DRM_PB6 0x1170
-#define HDMI_FC_DRM_PB7 0x1171
-#define HDMI_FC_DRM_PB8 0x1172
-#define HDMI_FC_DRM_PB9 0x1173
-#define HDMI_FC_DRM_PB10 0x1174
-#define HDMI_FC_DRM_PB11 0x1175
-#define HDMI_FC_DRM_PB12 0x1176
-#define HDMI_FC_DRM_PB13 0x1177
-#define HDMI_FC_DRM_PB14 0x1178
-#define HDMI_FC_DRM_PB15 0x1179
-#define HDMI_FC_DRM_PB16 0x117A
-#define HDMI_FC_DRM_PB17 0x117B
-#define HDMI_FC_DRM_PB18 0x117C
-#define HDMI_FC_DRM_PB19 0x117D
-#define HDMI_FC_DRM_PB20 0x117E
-#define HDMI_FC_DRM_PB21 0x117F
-#define HDMI_FC_DRM_PB22 0x1180
-#define HDMI_FC_DRM_PB23 0x1181
-#define HDMI_FC_DRM_PB24 0x1182
-#define HDMI_FC_DRM_PB25 0x1183
-#define HDMI_FC_DRM_PB26 0x1184
-
-#define HDMI_FC_DBGFORCE 0x1200
-#define HDMI_FC_DBGAUD0CH0 0x1201
-#define HDMI_FC_DBGAUD1CH0 0x1202
-#define HDMI_FC_DBGAUD2CH0 0x1203
-#define HDMI_FC_DBGAUD0CH1 0x1204
-#define HDMI_FC_DBGAUD1CH1 0x1205
-#define HDMI_FC_DBGAUD2CH1 0x1206
-#define HDMI_FC_DBGAUD0CH2 0x1207
-#define HDMI_FC_DBGAUD1CH2 0x1208
-#define HDMI_FC_DBGAUD2CH2 0x1209
-#define HDMI_FC_DBGAUD0CH3 0x120A
-#define HDMI_FC_DBGAUD1CH3 0x120B
-#define HDMI_FC_DBGAUD2CH3 0x120C
-#define HDMI_FC_DBGAUD0CH4 0x120D
-#define HDMI_FC_DBGAUD1CH4 0x120E
-#define HDMI_FC_DBGAUD2CH4 0x120F
-#define HDMI_FC_DBGAUD0CH5 0x1210
-#define HDMI_FC_DBGAUD1CH5 0x1211
-#define HDMI_FC_DBGAUD2CH5 0x1212
-#define HDMI_FC_DBGAUD0CH6 0x1213
-#define HDMI_FC_DBGAUD1CH6 0x1214
-#define HDMI_FC_DBGAUD2CH6 0x1215
-#define HDMI_FC_DBGAUD0CH7 0x1216
-#define HDMI_FC_DBGAUD1CH7 0x1217
-#define HDMI_FC_DBGAUD2CH7 0x1218
-#define HDMI_FC_DBGTMDS0 0x1219
-#define HDMI_FC_DBGTMDS1 0x121A
-#define HDMI_FC_DBGTMDS2 0x121B
-
-/* HDMI Source PHY Registers */
-#define HDMI_PHY_CONF0 0x3000
-#define HDMI_PHY_TST0 0x3001
-#define HDMI_PHY_TST1 0x3002
-#define HDMI_PHY_TST2 0x3003
-#define HDMI_PHY_STAT0 0x3004
-#define HDMI_PHY_INT0 0x3005
-#define HDMI_PHY_MASK0 0x3006
-#define HDMI_PHY_POL0 0x3007
-
-/* HDMI Master PHY Registers */
-#define HDMI_PHY_I2CM_SLAVE_ADDR 0x3020
-#define HDMI_PHY_I2CM_ADDRESS_ADDR 0x3021
-#define HDMI_PHY_I2CM_DATAO_1_ADDR 0x3022
-#define HDMI_PHY_I2CM_DATAO_0_ADDR 0x3023
-#define HDMI_PHY_I2CM_DATAI_1_ADDR 0x3024
-#define HDMI_PHY_I2CM_DATAI_0_ADDR 0x3025
-#define HDMI_PHY_I2CM_OPERATION_ADDR 0x3026
-#define HDMI_PHY_I2CM_INT_ADDR 0x3027
-#define HDMI_PHY_I2CM_CTLINT_ADDR 0x3028
-#define HDMI_PHY_I2CM_DIV_ADDR 0x3029
-#define HDMI_PHY_I2CM_SOFTRSTZ_ADDR 0x302a
-#define HDMI_PHY_I2CM_SS_SCL_HCNT_1_ADDR 0x302b
-#define HDMI_PHY_I2CM_SS_SCL_HCNT_0_ADDR 0x302c
-#define HDMI_PHY_I2CM_SS_SCL_LCNT_1_ADDR 0x302d
-#define HDMI_PHY_I2CM_SS_SCL_LCNT_0_ADDR 0x302e
-#define HDMI_PHY_I2CM_FS_SCL_HCNT_1_ADDR 0x302f
-#define HDMI_PHY_I2CM_FS_SCL_HCNT_0_ADDR 0x3030
-#define HDMI_PHY_I2CM_FS_SCL_LCNT_1_ADDR 0x3031
-#define HDMI_PHY_I2CM_FS_SCL_LCNT_0_ADDR 0x3032
-#define HDMI_PHY_I2CM_SDA_HOLD 0x3033
-#define HDMI_JTAG_PHY_CONFIG 0x3034
-
-/* Audio Sampler Registers */
-#define HDMI_AUD_CONF0 0x3100
-#define HDMI_AUD_CONF1 0x3101
-#define HDMI_AUD_INT 0x3102
-#define HDMI_AUD_CONF2 0x3103
-#define HDMI_AUD_INT1 0x3104
-#define HDMI_AUD_N1 0x3200
-#define HDMI_AUD_N2 0x3201
-#define HDMI_AUD_N3 0x3202
-#define HDMI_AUD_CTS1 0x3203
-#define HDMI_AUD_CTS2 0x3204
-#define HDMI_AUD_CTS3 0x3205
-#define HDMI_AUD_INPUTCLKFS 0x3206
-#define HDMI_AUD_SPDIFINT 0x3302
-#define HDMI_AUD_CONF0_HBR 0x3400
-#define HDMI_AUD_HBR_STATUS 0x3401
-#define HDMI_AUD_HBR_INT 0x3402
-#define HDMI_AUD_HBR_POL 0x3403
-#define HDMI_AUD_HBR_MASK 0x3404
-
-/*
- * Generic Parallel Audio Interface Registers
- * Not used as GPAUD interface is not enabled in hw
- */
-#define HDMI_GP_CONF0 0x3500
-#define HDMI_GP_CONF1 0x3501
-#define HDMI_GP_CONF2 0x3502
-#define HDMI_GP_MASK 0x3506
-
-/* Audio DMA Registers */
-#define HDMI_AHB_DMA_CONF0 0x3600
-#define HDMI_AHB_DMA_START 0x3601
-#define HDMI_AHB_DMA_STOP 0x3602
-#define HDMI_AHB_DMA_THRSLD 0x3603
-#define HDMI_AHB_DMA_STRADDR0 0x3604
-#define HDMI_AHB_DMA_STRADDR1 0x3605
-#define HDMI_AHB_DMA_STRADDR2 0x3606
-#define HDMI_AHB_DMA_STRADDR3 0x3607
-#define HDMI_AHB_DMA_STPADDR0 0x3608
-#define HDMI_AHB_DMA_STPADDR1 0x3609
-#define HDMI_AHB_DMA_STPADDR2 0x360a
-#define HDMI_AHB_DMA_STPADDR3 0x360b
-#define HDMI_AHB_DMA_BSTADDR0 0x360c
-#define HDMI_AHB_DMA_BSTADDR1 0x360d
-#define HDMI_AHB_DMA_BSTADDR2 0x360e
-#define HDMI_AHB_DMA_BSTADDR3 0x360f
-#define HDMI_AHB_DMA_MBLENGTH0 0x3610
-#define HDMI_AHB_DMA_MBLENGTH1 0x3611
-#define HDMI_AHB_DMA_STAT 0x3612
-#define HDMI_AHB_DMA_INT 0x3613
-#define HDMI_AHB_DMA_MASK 0x3614
-#define HDMI_AHB_DMA_POL 0x3615
-#define HDMI_AHB_DMA_CONF1 0x3616
-#define HDMI_AHB_DMA_BUFFSTAT 0x3617
-#define HDMI_AHB_DMA_BUFFINT 0x3618
-#define HDMI_AHB_DMA_BUFFMASK 0x3619
-#define HDMI_AHB_DMA_BUFFPOL 0x361a
-
-/* Main Controller Registers */
-#define HDMI_MC_SFRDIV 0x4000
-#define HDMI_MC_CLKDIS 0x4001
-#define HDMI_MC_SWRSTZ 0x4002
-#define HDMI_MC_OPCTRL 0x4003
-#define HDMI_MC_FLOWCTRL 0x4004
-#define HDMI_MC_PHYRSTZ 0x4005
-#define HDMI_MC_LOCKONCLOCK 0x4006
-#define HDMI_MC_HEACPHY_RST 0x4007
-
-/* Color Space  Converter Registers */
-#define HDMI_CSC_CFG 0x4100
-#define HDMI_CSC_SCALE 0x4101
-#define HDMI_CSC_COEF_A1_MSB 0x4102
-#define HDMI_CSC_COEF_A1_LSB 0x4103
-#define HDMI_CSC_COEF_A2_MSB 0x4104
-#define HDMI_CSC_COEF_A2_LSB 0x4105
-#define HDMI_CSC_COEF_A3_MSB 0x4106
-#define HDMI_CSC_COEF_A3_LSB 0x4107
-#define HDMI_CSC_COEF_A4_MSB 0x4108
-#define HDMI_CSC_COEF_A4_LSB 0x4109
-#define HDMI_CSC_COEF_B1_MSB 0x410A
-#define HDMI_CSC_COEF_B1_LSB 0x410B
-#define HDMI_CSC_COEF_B2_MSB 0x410C
-#define HDMI_CSC_COEF_B2_LSB 0x410D
-#define HDMI_CSC_COEF_B3_MSB 0x410E
-#define HDMI_CSC_COEF_B3_LSB 0x410F
-#define HDMI_CSC_COEF_B4_MSB 0x4110
-#define HDMI_CSC_COEF_B4_LSB 0x4111
-#define HDMI_CSC_COEF_C1_MSB 0x4112
-#define HDMI_CSC_COEF_C1_LSB 0x4113
-#define HDMI_CSC_COEF_C2_MSB 0x4114
-#define HDMI_CSC_COEF_C2_LSB 0x4115
-#define HDMI_CSC_COEF_C3_MSB 0x4116
-#define HDMI_CSC_COEF_C3_LSB 0x4117
-#define HDMI_CSC_COEF_C4_MSB 0x4118
-#define HDMI_CSC_COEF_C4_LSB 0x4119
-
-/* HDCP Encryption Engine Registers */
-#define HDMI_A_HDCPCFG0 0x5000
-#define HDMI_A_HDCPCFG1 0x5001
-#define HDMI_A_HDCPOBS0 0x5002
-#define HDMI_A_HDCPOBS1 0x5003
-#define HDMI_A_HDCPOBS2 0x5004
-#define HDMI_A_HDCPOBS3 0x5005
-#define HDMI_A_APIINTCLR 0x5006
-#define HDMI_A_APIINTSTAT 0x5007
-#define HDMI_A_APIINTMSK 0x5008
-#define HDMI_A_VIDPOLCFG 0x5009
-#define HDMI_A_OESSWCFG 0x500A
-#define HDMI_A_TIMER1SETUP0 0x500B
-#define HDMI_A_TIMER1SETUP1 0x500C
-#define HDMI_A_TIMER2SETUP0 0x500D
-#define HDMI_A_TIMER2SETUP1 0x500E
-#define HDMI_A_100MSCFG 0x500F
-#define HDMI_A_2SCFG0 0x5010
-#define HDMI_A_2SCFG1 0x5011
-#define HDMI_A_5SCFG0 0x5012
-#define HDMI_A_5SCFG1 0x5013
-#define HDMI_A_SRMVERLSB 0x5014
-#define HDMI_A_SRMVERMSB 0x5015
-#define HDMI_A_SRMCTRL 0x5016
-#define HDMI_A_SFRSETUP 0x5017
-#define HDMI_A_I2CHSETUP 0x5018
-#define HDMI_A_INTSETUP 0x5019
-#define HDMI_A_PRESETUP 0x501A
-#define HDMI_A_SRM_BASE 0x5020
-
-/* HDCP Registers */
-#define HDMI_HDCPREG_RMCTL 0x780e
-#define HDMI_HDCPREG_RMSTS 0x780f
-#define HDMI_HDCPREG_SEED0 0x7810
-#define HDMI_HDCPREG_SEED1 0x7811
-#define HDMI_HDCPREG_DPK0 0x7812
-#define HDMI_HDCPREG_DPK1 0x7813
-#define HDMI_HDCPREG_DPK2 0x7814
-#define HDMI_HDCPREG_DPK3 0x7815
-#define HDMI_HDCPREG_DPK4 0x7816
-#define HDMI_HDCPREG_DPK5 0x7817
-#define HDMI_HDCPREG_DPK6 0x7818
-#define HDMI_HDCP2REG_CTRL 0x7904
-#define HDMI_HDCP2REG_MASK 0x790c
-#define HDMI_HDCP2REG_MUTE 0x7912
-
-/* CEC Engine Registers */
-#define HDMI_CEC_CTRL 0x7D00
-#define HDMI_CEC_STAT 0x7D01
-#define HDMI_CEC_MASK 0x7D02
-#define HDMI_CEC_POLARITY 0x7D03
-#define HDMI_CEC_INT 0x7D04
-#define HDMI_CEC_ADDR_L 0x7D05
-#define HDMI_CEC_ADDR_H 0x7D06
-#define HDMI_CEC_TX_CNT 0x7D07
-#define HDMI_CEC_RX_CNT 0x7D08
-#define HDMI_CEC_TX_DATA0 0x7D10
-#define HDMI_CEC_TX_DATA1 0x7D11
-#define HDMI_CEC_TX_DATA2 0x7D12
-#define HDMI_CEC_TX_DATA3 0x7D13
-#define HDMI_CEC_TX_DATA4 0x7D14
-#define HDMI_CEC_TX_DATA5 0x7D15
-#define HDMI_CEC_TX_DATA6 0x7D16
-#define HDMI_CEC_TX_DATA7 0x7D17
-#define HDMI_CEC_TX_DATA8 0x7D18
-#define HDMI_CEC_TX_DATA9 0x7D19
-#define HDMI_CEC_TX_DATA10 0x7D1a
-#define HDMI_CEC_TX_DATA11 0x7D1b
-#define HDMI_CEC_TX_DATA12 0x7D1c
-#define HDMI_CEC_TX_DATA13 0x7D1d
-#define HDMI_CEC_TX_DATA14 0x7D1e
-#define HDMI_CEC_TX_DATA15 0x7D1f
-#define HDMI_CEC_RX_DATA0 0x7D20
-#define HDMI_CEC_RX_DATA1 0x7D21
-#define HDMI_CEC_RX_DATA2 0x7D22
-#define HDMI_CEC_RX_DATA3 0x7D23
-#define HDMI_CEC_RX_DATA4 0x7D24
-#define HDMI_CEC_RX_DATA5 0x7D25
-#define HDMI_CEC_RX_DATA6 0x7D26
-#define HDMI_CEC_RX_DATA7 0x7D27
-#define HDMI_CEC_RX_DATA8 0x7D28
-#define HDMI_CEC_RX_DATA9 0x7D29
-#define HDMI_CEC_RX_DATA10 0x7D2a
-#define HDMI_CEC_RX_DATA11 0x7D2b
-#define HDMI_CEC_RX_DATA12 0x7D2c
-#define HDMI_CEC_RX_DATA13 0x7D2d
-#define HDMI_CEC_RX_DATA14 0x7D2e
-#define HDMI_CEC_RX_DATA15 0x7D2f
-#define HDMI_CEC_LOCK 0x7D30
-#define HDMI_CEC_WKUPCTRL 0x7D31
-
-/* I2C Master Registers (E-DDC) */
-#define HDMI_I2CM_SLAVE 0x7E00
-#define HDMI_I2CM_ADDRESS 0x7E01
-#define HDMI_I2CM_DATAO 0x7E02
-#define HDMI_I2CM_DATAI 0x7E03
-#define HDMI_I2CM_OPERATION 0x7E04
-#define HDMI_I2CM_INT 0x7E05
-#define HDMI_I2CM_CTLINT 0x7E06
-#define HDMI_I2CM_DIV 0x7E07
-#define HDMI_I2CM_SEGADDR 0x7E08
-#define HDMI_I2CM_SOFTRSTZ 0x7E09
-#define HDMI_I2CM_SEGPTR 0x7E0A
-#define HDMI_I2CM_SS_SCL_HCNT_1_ADDR 0x7E0B
-#define HDMI_I2CM_SS_SCL_HCNT_0_ADDR 0x7E0C
-#define HDMI_I2CM_SS_SCL_LCNT_1_ADDR 0x7E0D
-#define HDMI_I2CM_SS_SCL_LCNT_0_ADDR 0x7E0E
-#define HDMI_I2CM_FS_SCL_HCNT_1_ADDR 0x7E0F
-#define HDMI_I2CM_FS_SCL_HCNT_0_ADDR 0x7E10
-#define HDMI_I2CM_FS_SCL_LCNT_1_ADDR 0x7E11
-#define HDMI_I2CM_FS_SCL_LCNT_0_ADDR 0x7E12
-#define HDMI_I2CM_SDA_HOLD 0x7E13
-#define HDMI_I2CM_SCDC_READ_UPDATE_ON 0x7E14
-
-#define HDMI_I2CM_MAX_REG 0x7E31
-
-enum {
-	/* PRODUCT_ID0 field values */
-	HDMI_PRODUCT_ID0_HDMI_TX = 0xa0,
-
-	/* PRODUCT_ID1 field values */
-	HDMI_PRODUCT_ID1_HDCP = 0xc0,
-	HDMI_PRODUCT_ID1_HDMI_RX = 0x02,
-	HDMI_PRODUCT_ID1_HDMI_TX = 0x01,
-
-	/* CONFIG0_ID field values */
-	HDMI_CONFIG0_I2S = 0x10,
-	HDMI_CONFIG0_CEC = 0x02,
-
-	/* CONFIG1_ID field values */
-	HDMI_CONFIG1_AHB = 0x01,
-
-	/* CONFIG3_ID field values */
-	HDMI_CONFIG3_AHBAUDDMA = 0x02,
-	HDMI_CONFIG3_GPAUD = 0x01,
-
-	/* IH_FC_INT2 field values */
-	HDMI_IH_FC_INT2_OVERFLOW_MASK = 0x03,
-	HDMI_IH_FC_INT2_LOW_PRIORITY_OVERFLOW = 0x02,
-	HDMI_IH_FC_INT2_HIGH_PRIORITY_OVERFLOW = 0x01,
-
-	/* IH_FC_STAT2 field values */
-	HDMI_IH_FC_STAT2_OVERFLOW_MASK = 0x03,
-	HDMI_IH_FC_STAT2_LOW_PRIORITY_OVERFLOW = 0x02,
-	HDMI_IH_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 0x01,
-
-	/* IH_PHY_STAT0 field values */
-	HDMI_IH_PHY_STAT0_RX_SENSE3 = 0x20,
-	HDMI_IH_PHY_STAT0_RX_SENSE2 = 0x10,
-	HDMI_IH_PHY_STAT0_RX_SENSE1 = 0x8,
-	HDMI_IH_PHY_STAT0_RX_SENSE0 = 0x4,
-	HDMI_IH_PHY_STAT0_TX_PHY_LOCK = 0x2,
-	HDMI_IH_PHY_STAT0_HPD = 0x1,
-
-	/* IH_I2CM_STAT0 and IH_MUTE_I2CM_STAT0 field values */
-	HDMI_IH_I2CM_STAT0_DONE = 0x2,
-	HDMI_IH_I2CM_STAT0_ERROR = 0x1,
-
-	/* IH_MUTE_I2CMPHY_STAT0 field values */
-	HDMI_IH_MUTE_I2CMPHY_STAT0_I2CMPHYDONE = 0x2,
-	HDMI_IH_MUTE_I2CMPHY_STAT0_I2CMPHYERROR = 0x1,
-
-	/* IH_AHBDMAAUD_STAT0 field values */
-	HDMI_IH_AHBDMAAUD_STAT0_ERROR = 0x20,
-	HDMI_IH_AHBDMAAUD_STAT0_LOST = 0x10,
-	HDMI_IH_AHBDMAAUD_STAT0_RETRY = 0x08,
-	HDMI_IH_AHBDMAAUD_STAT0_DONE = 0x04,
-	HDMI_IH_AHBDMAAUD_STAT0_BUFFFULL = 0x02,
-	HDMI_IH_AHBDMAAUD_STAT0_BUFFEMPTY = 0x01,
-
-	/* IH_MUTE_FC_STAT2 field values */
-	HDMI_IH_MUTE_FC_STAT2_OVERFLOW_MASK = 0x03,
-	HDMI_IH_MUTE_FC_STAT2_LOW_PRIORITY_OVERFLOW = 0x02,
-	HDMI_IH_MUTE_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 0x01,
-
-	/* IH_MUTE_AHBDMAAUD_STAT0 field values */
-	HDMI_IH_MUTE_AHBDMAAUD_STAT0_ERROR = 0x20,
-	HDMI_IH_MUTE_AHBDMAAUD_STAT0_LOST = 0x10,
-	HDMI_IH_MUTE_AHBDMAAUD_STAT0_RETRY = 0x08,
-	HDMI_IH_MUTE_AHBDMAAUD_STAT0_DONE = 0x04,
-	HDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFFULL = 0x02,
-	HDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFEMPTY = 0x01,
-
-	/* IH_MUTE field values */
-	HDMI_IH_MUTE_MUTE_WAKEUP_INTERRUPT = 0x2,
-	HDMI_IH_MUTE_MUTE_ALL_INTERRUPT = 0x1,
-
-	/* TX_INVID0 field values */
-	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_MASK = 0x80,
-	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_ENABLE = 0x80,
-	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_DISABLE = 0x00,
-	HDMI_TX_INVID0_VIDEO_MAPPING_MASK = 0x1F,
-	HDMI_TX_INVID0_VIDEO_MAPPING_OFFSET = 0,
-
-	/* TX_INSTUFFING field values */
-	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_MASK = 0x4,
-	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_ENABLE = 0x4,
-	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_DISABLE = 0x0,
-	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_MASK = 0x2,
-	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_ENABLE = 0x2,
-	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_DISABLE = 0x0,
-	HDMI_TX_INSTUFFING_GYDATA_STUFFING_MASK = 0x1,
-	HDMI_TX_INSTUFFING_GYDATA_STUFFING_ENABLE = 0x1,
-	HDMI_TX_INSTUFFING_GYDATA_STUFFING_DISABLE = 0x0,
-
-	/* VP_PR_CD field values */
-	HDMI_VP_PR_CD_COLOR_DEPTH_MASK = 0xF0,
-	HDMI_VP_PR_CD_COLOR_DEPTH_OFFSET = 4,
-	HDMI_VP_PR_CD_DESIRED_PR_FACTOR_MASK = 0x0F,
-	HDMI_VP_PR_CD_DESIRED_PR_FACTOR_OFFSET = 0,
-
-	/* VP_STUFF field values */
-	HDMI_VP_STUFF_IDEFAULT_PHASE_MASK = 0x20,
-	HDMI_VP_STUFF_IDEFAULT_PHASE_OFFSET = 5,
-	HDMI_VP_STUFF_IFIX_PP_TO_LAST_MASK = 0x10,
-	HDMI_VP_STUFF_IFIX_PP_TO_LAST_OFFSET = 4,
-	HDMI_VP_STUFF_ICX_GOTO_P0_ST_MASK = 0x8,
-	HDMI_VP_STUFF_ICX_GOTO_P0_ST_OFFSET = 3,
-	HDMI_VP_STUFF_YCC422_STUFFING_MASK = 0x4,
-	HDMI_VP_STUFF_YCC422_STUFFING_STUFFING_MODE = 0x4,
-	HDMI_VP_STUFF_YCC422_STUFFING_DIRECT_MODE = 0x0,
-	HDMI_VP_STUFF_PP_STUFFING_MASK = 0x2,
-	HDMI_VP_STUFF_PP_STUFFING_STUFFING_MODE = 0x2,
-	HDMI_VP_STUFF_PP_STUFFING_DIRECT_MODE = 0x0,
-	HDMI_VP_STUFF_PR_STUFFING_MASK = 0x1,
-	HDMI_VP_STUFF_PR_STUFFING_STUFFING_MODE = 0x1,
-	HDMI_VP_STUFF_PR_STUFFING_DIRECT_MODE = 0x0,
-
-	/* VP_CONF field values */
-	HDMI_VP_CONF_BYPASS_EN_MASK = 0x40,
-	HDMI_VP_CONF_BYPASS_EN_ENABLE = 0x40,
-	HDMI_VP_CONF_BYPASS_EN_DISABLE = 0x00,
-	HDMI_VP_CONF_PP_EN_ENMASK = 0x20,
-	HDMI_VP_CONF_PP_EN_ENABLE = 0x20,
-	HDMI_VP_CONF_PP_EN_DISABLE = 0x00,
-	HDMI_VP_CONF_PR_EN_MASK = 0x10,
-	HDMI_VP_CONF_PR_EN_ENABLE = 0x10,
-	HDMI_VP_CONF_PR_EN_DISABLE = 0x00,
-	HDMI_VP_CONF_YCC422_EN_MASK = 0x8,
-	HDMI_VP_CONF_YCC422_EN_ENABLE = 0x8,
-	HDMI_VP_CONF_YCC422_EN_DISABLE = 0x0,
-	HDMI_VP_CONF_BYPASS_SELECT_MASK = 0x4,
-	HDMI_VP_CONF_BYPASS_SELECT_VID_PACKETIZER = 0x4,
-	HDMI_VP_CONF_BYPASS_SELECT_PIX_REPEATER = 0x0,
-	HDMI_VP_CONF_OUTPUT_SELECTOR_MASK = 0x3,
-	HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS = 0x3,
-	HDMI_VP_CONF_OUTPUT_SELECTOR_YCC422 = 0x1,
-	HDMI_VP_CONF_OUTPUT_SELECTOR_PP = 0x0,
-
-	/* VP_REMAP field values */
-	HDMI_VP_REMAP_MASK = 0x3,
-	HDMI_VP_REMAP_YCC422_24bit = 0x2,
-	HDMI_VP_REMAP_YCC422_20bit = 0x1,
-	HDMI_VP_REMAP_YCC422_16bit = 0x0,
-
-	/* FC_INVIDCONF field values */
-	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_MASK = 0x80,
-	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_ACTIVE = 0x80,
-	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_INACTIVE = 0x00,
-	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_MASK = 0x40,
-	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_HIGH = 0x40,
-	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_LOW = 0x00,
-	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_MASK = 0x20,
-	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_HIGH = 0x20,
-	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_LOW = 0x00,
-	HDMI_FC_INVIDCONF_DE_IN_POLARITY_MASK = 0x10,
-	HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_HIGH = 0x10,
-	HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_LOW = 0x00,
-	HDMI_FC_INVIDCONF_DVI_MODEZ_MASK = 0x8,
-	HDMI_FC_INVIDCONF_DVI_MODEZ_HDMI_MODE = 0x8,
-	HDMI_FC_INVIDCONF_DVI_MODEZ_DVI_MODE = 0x0,
-	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_MASK = 0x2,
-	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_HIGH = 0x2,
-	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_LOW = 0x0,
-	HDMI_FC_INVIDCONF_IN_I_P_MASK = 0x1,
-	HDMI_FC_INVIDCONF_IN_I_P_INTERLACED = 0x1,
-	HDMI_FC_INVIDCONF_IN_I_P_PROGRESSIVE = 0x0,
-
-	/* FC_AUDICONF0 field values */
-	HDMI_FC_AUDICONF0_CC_OFFSET = 4,
-	HDMI_FC_AUDICONF0_CC_MASK = 0x70,
-	HDMI_FC_AUDICONF0_CT_OFFSET = 0,
-	HDMI_FC_AUDICONF0_CT_MASK = 0xF,
-
-	/* FC_AUDICONF1 field values */
-	HDMI_FC_AUDICONF1_SS_OFFSET = 4,
-	HDMI_FC_AUDICONF1_SS_MASK = 0x30,
-	HDMI_FC_AUDICONF1_SF_OFFSET = 0,
-	HDMI_FC_AUDICONF1_SF_MASK = 0x7,
-
-	/* FC_AUDICONF3 field values */
-	HDMI_FC_AUDICONF3_LFEPBL_OFFSET = 5,
-	HDMI_FC_AUDICONF3_LFEPBL_MASK = 0x60,
-	HDMI_FC_AUDICONF3_DM_INH_OFFSET = 4,
-	HDMI_FC_AUDICONF3_DM_INH_MASK = 0x10,
-	HDMI_FC_AUDICONF3_LSV_OFFSET = 0,
-	HDMI_FC_AUDICONF3_LSV_MASK = 0xF,
-
-	/* FC_AUDSCHNLS0 field values */
-	HDMI_FC_AUDSCHNLS0_CGMSA_OFFSET = 4,
-	HDMI_FC_AUDSCHNLS0_CGMSA_MASK = 0x30,
-	HDMI_FC_AUDSCHNLS0_COPYRIGHT_OFFSET = 0,
-	HDMI_FC_AUDSCHNLS0_COPYRIGHT_MASK = 0x01,
-
-	/* FC_AUDSCHNLS3-6 field values */
-	HDMI_FC_AUDSCHNLS3_OIEC_CH0_OFFSET = 0,
-	HDMI_FC_AUDSCHNLS3_OIEC_CH0_MASK = 0x0f,
-	HDMI_FC_AUDSCHNLS3_OIEC_CH1_OFFSET = 4,
-	HDMI_FC_AUDSCHNLS3_OIEC_CH1_MASK = 0xf0,
-	HDMI_FC_AUDSCHNLS4_OIEC_CH2_OFFSET = 0,
-	HDMI_FC_AUDSCHNLS4_OIEC_CH2_MASK = 0x0f,
-	HDMI_FC_AUDSCHNLS4_OIEC_CH3_OFFSET = 4,
-	HDMI_FC_AUDSCHNLS4_OIEC_CH3_MASK = 0xf0,
-
-	HDMI_FC_AUDSCHNLS5_OIEC_CH0_OFFSET = 0,
-	HDMI_FC_AUDSCHNLS5_OIEC_CH0_MASK = 0x0f,
-	HDMI_FC_AUDSCHNLS5_OIEC_CH1_OFFSET = 4,
-	HDMI_FC_AUDSCHNLS5_OIEC_CH1_MASK = 0xf0,
-	HDMI_FC_AUDSCHNLS6_OIEC_CH2_OFFSET = 0,
-	HDMI_FC_AUDSCHNLS6_OIEC_CH2_MASK = 0x0f,
-	HDMI_FC_AUDSCHNLS6_OIEC_CH3_OFFSET = 4,
-	HDMI_FC_AUDSCHNLS6_OIEC_CH3_MASK = 0xf0,
-
-	/* HDMI_FC_AUDSCHNLS7 field values */
-	HDMI_FC_AUDSCHNLS7_ACCURACY_OFFSET = 4,
-	HDMI_FC_AUDSCHNLS7_ACCURACY_MASK = 0x30,
-
-	/* HDMI_FC_AUDSCHNLS8 field values */
-	HDMI_FC_AUDSCHNLS8_ORIGSAMPFREQ_MASK = 0xf0,
-	HDMI_FC_AUDSCHNLS8_ORIGSAMPFREQ_OFFSET = 4,
-	HDMI_FC_AUDSCHNLS8_WORDLEGNTH_MASK = 0x0f,
-	HDMI_FC_AUDSCHNLS8_WORDLEGNTH_OFFSET = 0,
-
-	/* FC_AUDSCONF field values */
-	HDMI_FC_AUDSCONF_AUD_PACKET_SAMPFIT_MASK = 0xF0,
-	HDMI_FC_AUDSCONF_AUD_PACKET_SAMPFIT_OFFSET = 4,
-	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_MASK = 0x1,
-	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_OFFSET = 0,
-	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_LAYOUT1 = 0x1,
-	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_LAYOUT0 = 0x0,
-
-	/* FC_STAT2 field values */
-	HDMI_FC_STAT2_OVERFLOW_MASK = 0x03,
-	HDMI_FC_STAT2_LOW_PRIORITY_OVERFLOW = 0x02,
-	HDMI_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 0x01,
-
-	/* FC_INT2 field values */
-	HDMI_FC_INT2_OVERFLOW_MASK = 0x03,
-	HDMI_FC_INT2_LOW_PRIORITY_OVERFLOW = 0x02,
-	HDMI_FC_INT2_HIGH_PRIORITY_OVERFLOW = 0x01,
-
-	/* FC_MASK2 field values */
-	HDMI_FC_MASK2_OVERFLOW_MASK = 0x03,
-	HDMI_FC_MASK2_LOW_PRIORITY_OVERFLOW = 0x02,
-	HDMI_FC_MASK2_HIGH_PRIORITY_OVERFLOW = 0x01,
-
-	/* FC_PRCONF field values */
-	HDMI_FC_PRCONF_INCOMING_PR_FACTOR_MASK = 0xF0,
-	HDMI_FC_PRCONF_INCOMING_PR_FACTOR_OFFSET = 4,
-	HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_MASK = 0x0F,
-	HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_OFFSET = 0,
-
-	/* FC_PACKET_TX_EN field values */
-	HDMI_FC_PACKET_TX_EN_DRM_MASK = 0x80,
-	HDMI_FC_PACKET_TX_EN_DRM_ENABLE = 0x80,
-	HDMI_FC_PACKET_TX_EN_DRM_DISABLE = 0x00,
-
-	/* FC_AVICONF0-FC_AVICONF3 field values */
-	HDMI_FC_AVICONF0_PIX_FMT_MASK = 0x03,
-	HDMI_FC_AVICONF0_PIX_FMT_RGB = 0x00,
-	HDMI_FC_AVICONF0_PIX_FMT_YCBCR422 = 0x01,
-	HDMI_FC_AVICONF0_PIX_FMT_YCBCR444 = 0x02,
-	HDMI_FC_AVICONF0_ACTIVE_FMT_MASK = 0x40,
-	HDMI_FC_AVICONF0_ACTIVE_FMT_INFO_PRESENT = 0x40,
-	HDMI_FC_AVICONF0_ACTIVE_FMT_NO_INFO = 0x00,
-	HDMI_FC_AVICONF0_BAR_DATA_MASK = 0x0C,
-	HDMI_FC_AVICONF0_BAR_DATA_NO_DATA = 0x00,
-	HDMI_FC_AVICONF0_BAR_DATA_VERT_BAR = 0x04,
-	HDMI_FC_AVICONF0_BAR_DATA_HORIZ_BAR = 0x08,
-	HDMI_FC_AVICONF0_BAR_DATA_VERT_HORIZ_BAR = 0x0C,
-	HDMI_FC_AVICONF0_SCAN_INFO_MASK = 0x30,
-	HDMI_FC_AVICONF0_SCAN_INFO_OVERSCAN = 0x10,
-	HDMI_FC_AVICONF0_SCAN_INFO_UNDERSCAN = 0x20,
-	HDMI_FC_AVICONF0_SCAN_INFO_NODATA = 0x00,
-
-	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_MASK = 0x0F,
-	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_USE_CODED = 0x08,
-	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_4_3 = 0x09,
-	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_16_9 = 0x0A,
-	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_14_9 = 0x0B,
-	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_MASK = 0x30,
-	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_NO_DATA = 0x00,
-	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_4_3 = 0x10,
-	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_16_9 = 0x20,
-	HDMI_FC_AVICONF1_COLORIMETRY_MASK = 0xC0,
-	HDMI_FC_AVICONF1_COLORIMETRY_NO_DATA = 0x00,
-	HDMI_FC_AVICONF1_COLORIMETRY_SMPTE = 0x40,
-	HDMI_FC_AVICONF1_COLORIMETRY_ITUR = 0x80,
-	HDMI_FC_AVICONF1_COLORIMETRY_EXTENDED_INFO = 0xC0,
-
-	HDMI_FC_AVICONF2_SCALING_MASK = 0x03,
-	HDMI_FC_AVICONF2_SCALING_NONE = 0x00,
-	HDMI_FC_AVICONF2_SCALING_HORIZ = 0x01,
-	HDMI_FC_AVICONF2_SCALING_VERT = 0x02,
-	HDMI_FC_AVICONF2_SCALING_HORIZ_VERT = 0x03,
-	HDMI_FC_AVICONF2_RGB_QUANT_MASK = 0x0C,
-	HDMI_FC_AVICONF2_RGB_QUANT_DEFAULT = 0x00,
-	HDMI_FC_AVICONF2_RGB_QUANT_LIMITED_RANGE = 0x04,
-	HDMI_FC_AVICONF2_RGB_QUANT_FULL_RANGE = 0x08,
-	HDMI_FC_AVICONF2_EXT_COLORIMETRY_MASK = 0x70,
-	HDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC601 = 0x00,
-	HDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC709 = 0x10,
-	HDMI_FC_AVICONF2_EXT_COLORIMETRY_SYCC601 = 0x20,
-	HDMI_FC_AVICONF2_EXT_COLORIMETRY_ADOBE_YCC601 = 0x30,
-	HDMI_FC_AVICONF2_EXT_COLORIMETRY_ADOBE_RGB = 0x40,
-	HDMI_FC_AVICONF2_IT_CONTENT_MASK = 0x80,
-	HDMI_FC_AVICONF2_IT_CONTENT_NO_DATA = 0x00,
-	HDMI_FC_AVICONF2_IT_CONTENT_VALID = 0x80,
-
-	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_MASK = 0x03,
-	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_GRAPHICS = 0x00,
-	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_PHOTO = 0x01,
-	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_CINEMA = 0x02,
-	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_GAME = 0x03,
-	HDMI_FC_AVICONF3_QUANT_RANGE_MASK = 0x0C,
-	HDMI_FC_AVICONF3_QUANT_RANGE_LIMITED = 0x00,
-	HDMI_FC_AVICONF3_QUANT_RANGE_FULL = 0x04,
-
-	/* HDMI_FC_GCP */
-	HDMI_FC_GCP_SET_AVMUTE = 0x2,
-	HDMI_FC_GCP_CLEAR_AVMUTE = 0x1,
-
-	/* FC_DBGFORCE field values */
-	HDMI_FC_DBGFORCE_FORCEAUDIO = 0x10,
-	HDMI_FC_DBGFORCE_FORCEVIDEO = 0x1,
-
-	/* FC_DATAUTO0 field values */
-	HDMI_FC_DATAUTO0_VSD_MASK = 0x08,
-	HDMI_FC_DATAUTO0_VSD_OFFSET = 3,
-
-	/* PHY_CONF0 field values */
-	HDMI_PHY_CONF0_PDZ_MASK = 0x80,
-	HDMI_PHY_CONF0_PDZ_OFFSET = 7,
-	HDMI_PHY_CONF0_ENTMDS_MASK = 0x40,
-	HDMI_PHY_CONF0_ENTMDS_OFFSET = 6,
-	HDMI_PHY_CONF0_SVSRET_MASK = 0x20,
-	HDMI_PHY_CONF0_SVSRET_OFFSET = 5,
-	HDMI_PHY_CONF0_GEN2_PDDQ_MASK = 0x10,
-	HDMI_PHY_CONF0_GEN2_PDDQ_OFFSET = 4,
-	HDMI_PHY_CONF0_GEN2_TXPWRON_MASK = 0x8,
-	HDMI_PHY_CONF0_GEN2_TXPWRON_OFFSET = 3,
-	HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE_MASK = 0x4,
-	HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE_OFFSET = 2,
-	HDMI_PHY_CONF0_SELDATAENPOL_MASK = 0x2,
-	HDMI_PHY_CONF0_SELDATAENPOL_OFFSET = 1,
-	HDMI_PHY_CONF0_SELDIPIF_MASK = 0x1,
-	HDMI_PHY_CONF0_SELDIPIF_OFFSET = 0,
-
-	/* PHY_TST0 field values */
-	HDMI_PHY_TST0_TSTCLR_MASK = 0x20,
-	HDMI_PHY_TST0_TSTCLR_OFFSET = 5,
-	HDMI_PHY_TST0_TSTEN_MASK = 0x10,
-	HDMI_PHY_TST0_TSTEN_OFFSET = 4,
-	HDMI_PHY_TST0_TSTCLK_MASK = 0x1,
-	HDMI_PHY_TST0_TSTCLK_OFFSET = 0,
-
-	/* PHY_STAT0 field values */
-	HDMI_PHY_RX_SENSE3 = 0x80,
-	HDMI_PHY_RX_SENSE2 = 0x40,
-	HDMI_PHY_RX_SENSE1 = 0x20,
-	HDMI_PHY_RX_SENSE0 = 0x10,
-	HDMI_PHY_HPD = 0x02,
-	HDMI_PHY_TX_PHY_LOCK = 0x01,
-
-	/* PHY_I2CM_SLAVE_ADDR field values */
-	HDMI_PHY_I2CM_SLAVE_ADDR_PHY_GEN2 = 0x69,
-	HDMI_PHY_I2CM_SLAVE_ADDR_HEAC_PHY = 0x49,
-
-	/* PHY_I2CM_OPERATION_ADDR field values */
-	HDMI_PHY_I2CM_OPERATION_ADDR_WRITE = 0x10,
-	HDMI_PHY_I2CM_OPERATION_ADDR_READ = 0x1,
-
-	/* HDMI_PHY_I2CM_INT_ADDR */
-	HDMI_PHY_I2CM_INT_ADDR_DONE_POL = 0x08,
-	HDMI_PHY_I2CM_INT_ADDR_DONE_MASK = 0x04,
-
-	/* HDMI_PHY_I2CM_CTLINT_ADDR */
-	HDMI_PHY_I2CM_CTLINT_ADDR_NAC_POL = 0x80,
-	HDMI_PHY_I2CM_CTLINT_ADDR_NAC_MASK = 0x40,
-	HDMI_PHY_I2CM_CTLINT_ADDR_ARBITRATION_POL = 0x08,
-	HDMI_PHY_I2CM_CTLINT_ADDR_ARBITRATION_MASK = 0x04,
-
-	/* AUD */
-	HDMI_AUD_CONF0_I2S_SELECT_MASK = 0x20,
-	HDMI_AUD_CONF0_I2S_2CHANNEL_ENABLE = 0x21,
-	HDMI_AUD_CONF0_I2S_4CHANNEL_ENABLE = 0x23,
-	HDMI_AUD_CONF0_I2S_6CHANNEL_ENABLE = 0x27,
-	HDMI_AUD_CONF0_I2S_8CHANNEL_ENABLE = 0x2F,
-	HDMI_AUD_CONF0_I2S_ALL_ENABLE = 0x2F,
-
-	/* AUD_CONF0 field values */
-	HDMI_AUD_CONF0_SW_RESET = 0x80,
-	HDMI_AUD_CONF0_I2S_SELECT = 0x20,
-	HDMI_AUD_CONF0_I2S_EN3 = 0x08,
-	HDMI_AUD_CONF0_I2S_EN2 = 0x04,
-	HDMI_AUD_CONF0_I2S_EN1 = 0x02,
-	HDMI_AUD_CONF0_I2S_EN0 = 0x01,
-
-	/* AUD_CONF1 field values */
-	HDMI_AUD_CONF1_MODE_I2S = 0x00,
-	HDMI_AUD_CONF1_MODE_RIGHT_J = 0x20,
-	HDMI_AUD_CONF1_MODE_LEFT_J = 0x40,
-	HDMI_AUD_CONF1_MODE_BURST_1 = 0x60,
-	HDMI_AUD_CONF1_MODE_BURST_2 = 0x80,
-	HDMI_AUD_CONF1_WIDTH_16 = 0x10,
-	HDMI_AUD_CONF1_WIDTH_24 = 0x18,
-
-	/* AUD_CTS3 field values */
-	HDMI_AUD_CTS3_N_SHIFT_OFFSET = 5,
-	HDMI_AUD_CTS3_N_SHIFT_MASK = 0xe0,
-	HDMI_AUD_CTS3_N_SHIFT_1 = 0,
-	HDMI_AUD_CTS3_N_SHIFT_16 = 0x20,
-	HDMI_AUD_CTS3_N_SHIFT_32 = 0x40,
-	HDMI_AUD_CTS3_N_SHIFT_64 = 0x60,
-	HDMI_AUD_CTS3_N_SHIFT_128 = 0x80,
-	HDMI_AUD_CTS3_N_SHIFT_256 = 0xa0,
-	/* note that the CTS3 MANUAL bit has been removed
-       from our part. Can't set it, will read as 0. */
-	HDMI_AUD_CTS3_CTS_MANUAL = 0x10,
-	HDMI_AUD_CTS3_AUDCTS19_16_MASK = 0x0f,
-
-	/* HDMI_AUD_INPUTCLKFS field values */
-	HDMI_AUD_INPUTCLKFS_128FS = 0,
-	HDMI_AUD_INPUTCLKFS_256FS = 1,
-	HDMI_AUD_INPUTCLKFS_512FS = 2,
-	HDMI_AUD_INPUTCLKFS_64FS = 4,
-
-	/* AHB_DMA_CONF0 field values */
-	HDMI_AHB_DMA_CONF0_SW_FIFO_RST_OFFSET = 7,
-	HDMI_AHB_DMA_CONF0_SW_FIFO_RST_MASK = 0x80,
-	HDMI_AHB_DMA_CONF0_HBR = 0x10,
-	HDMI_AHB_DMA_CONF0_EN_HLOCK_OFFSET = 3,
-	HDMI_AHB_DMA_CONF0_EN_HLOCK_MASK = 0x08,
-	HDMI_AHB_DMA_CONF0_INCR_TYPE_OFFSET = 1,
-	HDMI_AHB_DMA_CONF0_INCR_TYPE_MASK = 0x06,
-	HDMI_AHB_DMA_CONF0_INCR4 = 0x0,
-	HDMI_AHB_DMA_CONF0_INCR8 = 0x2,
-	HDMI_AHB_DMA_CONF0_INCR16 = 0x4,
-	HDMI_AHB_DMA_CONF0_BURST_MODE = 0x1,
-
-	/* HDMI_AHB_DMA_START field values */
-	HDMI_AHB_DMA_START_START_OFFSET = 0,
-	HDMI_AHB_DMA_START_START_MASK = 0x01,
-
-	/* HDMI_AHB_DMA_STOP field values */
-	HDMI_AHB_DMA_STOP_STOP_OFFSET = 0,
-	HDMI_AHB_DMA_STOP_STOP_MASK = 0x01,
-
-	/* AHB_DMA_STAT, AHB_DMA_INT, AHB_DMA_MASK, AHB_DMA_POL field values */
-	HDMI_AHB_DMA_DONE = 0x80,
-	HDMI_AHB_DMA_RETRY_SPLIT = 0x40,
-	HDMI_AHB_DMA_LOSTOWNERSHIP = 0x20,
-	HDMI_AHB_DMA_ERROR = 0x10,
-	HDMI_AHB_DMA_FIFO_THREMPTY = 0x04,
-	HDMI_AHB_DMA_FIFO_FULL = 0x02,
-	HDMI_AHB_DMA_FIFO_EMPTY = 0x01,
-
-	/* AHB_DMA_BUFFSTAT, AHB_DMA_BUFFINT,AHB_DMA_BUFFMASK,AHB_DMA_BUFFPOL values */
-	HDMI_AHB_DMA_BUFFSTAT_FULL = 0x02,
-	HDMI_AHB_DMA_BUFFSTAT_EMPTY = 0x01,
-
-	/* MC_CLKDIS field values */
-	HDMI_MC_CLKDIS_HDCPCLK_DISABLE = 0x40,
-	HDMI_MC_CLKDIS_CECCLK_DISABLE = 0x20,
-	HDMI_MC_CLKDIS_CSCCLK_DISABLE = 0x10,
-	HDMI_MC_CLKDIS_AUDCLK_DISABLE = 0x8,
-	HDMI_MC_CLKDIS_PREPCLK_DISABLE = 0x4,
-	HDMI_MC_CLKDIS_TMDSCLK_DISABLE = 0x2,
-	HDMI_MC_CLKDIS_PIXELCLK_DISABLE = 0x1,
-	HDMI_MC_CLKDIS_PIXELCLK_MASK = 0x1,
-	HDMI_MC_CLKDIS_PIXELCLK_ENABLE = 0,
-
-	/* MC_SWRSTZ field values */
-	HDMI_MC_SWRSTZ_I2SSWRST_REQ = 0x08,
-	HDMI_MC_SWRSTZ_TMDSSWRST_REQ = 0x02,
-
-	/* MC_FLOWCTRL field values */
-	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_MASK = 0x1,
-	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_IN_PATH = 0x1,
-	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_BYPASS = 0x0,
-
-	/* MC_PHYRSTZ field values */
-	HDMI_MC_PHYRSTZ_PHYRSTZ = 0x01,
-
-	/* MC_HEACPHY_RST field values */
-	HDMI_MC_HEACPHY_RST_ASSERT = 0x1,
-	HDMI_MC_HEACPHY_RST_DEASSERT = 0x0,
-
-	/* CSC_CFG field values */
-	HDMI_CSC_CFG_INTMODE_MASK = 0x30,
-	HDMI_CSC_CFG_INTMODE_OFFSET = 4,
-	HDMI_CSC_CFG_INTMODE_DISABLE = 0x00,
-	HDMI_CSC_CFG_INTMODE_CHROMA_INT_FORMULA1 = 0x10,
-	HDMI_CSC_CFG_INTMODE_CHROMA_INT_FORMULA2 = 0x20,
-	HDMI_CSC_CFG_DECMODE_MASK = 0x3,
-	HDMI_CSC_CFG_DECMODE_OFFSET = 0,
-	HDMI_CSC_CFG_DECMODE_DISABLE = 0x0,
-	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA1 = 0x1,
-	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA2 = 0x2,
-	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA3 = 0x3,
-
-	/* CSC_SCALE field values */
-	HDMI_CSC_SCALE_CSC_COLORDE_PTH_MASK = 0xF0,
-	HDMI_CSC_SCALE_CSC_COLORDE_PTH_24BPP = 0x00,
-	HDMI_CSC_SCALE_CSC_COLORDE_PTH_30BPP = 0x50,
-	HDMI_CSC_SCALE_CSC_COLORDE_PTH_36BPP = 0x60,
-	HDMI_CSC_SCALE_CSC_COLORDE_PTH_48BPP = 0x70,
-	HDMI_CSC_SCALE_CSCSCALE_MASK = 0x03,
-
-	/* A_HDCPCFG0 field values */
-	HDMI_A_HDCPCFG0_ELVENA_MASK = 0x80,
-	HDMI_A_HDCPCFG0_ELVENA_ENABLE = 0x80,
-	HDMI_A_HDCPCFG0_ELVENA_DISABLE = 0x00,
-	HDMI_A_HDCPCFG0_I2CFASTMODE_MASK = 0x40,
-	HDMI_A_HDCPCFG0_I2CFASTMODE_ENABLE = 0x40,
-	HDMI_A_HDCPCFG0_I2CFASTMODE_DISABLE = 0x00,
-	HDMI_A_HDCPCFG0_BYPENCRYPTION_MASK = 0x20,
-	HDMI_A_HDCPCFG0_BYPENCRYPTION_ENABLE = 0x20,
-	HDMI_A_HDCPCFG0_BYPENCRYPTION_DISABLE = 0x00,
-	HDMI_A_HDCPCFG0_SYNCRICHECK_MASK = 0x10,
-	HDMI_A_HDCPCFG0_SYNCRICHECK_ENABLE = 0x10,
-	HDMI_A_HDCPCFG0_SYNCRICHECK_DISABLE = 0x00,
-	HDMI_A_HDCPCFG0_AVMUTE_MASK = 0x8,
-	HDMI_A_HDCPCFG0_AVMUTE_ENABLE = 0x8,
-	HDMI_A_HDCPCFG0_AVMUTE_DISABLE = 0x0,
-	HDMI_A_HDCPCFG0_RXDETECT_MASK = 0x4,
-	HDMI_A_HDCPCFG0_RXDETECT_ENABLE = 0x4,
-	HDMI_A_HDCPCFG0_RXDETECT_DISABLE = 0x0,
-	HDMI_A_HDCPCFG0_EN11FEATURE_MASK = 0x2,
-	HDMI_A_HDCPCFG0_EN11FEATURE_ENABLE = 0x2,
-	HDMI_A_HDCPCFG0_EN11FEATURE_DISABLE = 0x0,
-	HDMI_A_HDCPCFG0_HDMIDVI_MASK = 0x1,
-	HDMI_A_HDCPCFG0_HDMIDVI_HDMI = 0x1,
-	HDMI_A_HDCPCFG0_HDMIDVI_DVI = 0x0,
-
-	/* A_HDCPCFG1 field values */
-	HDMI_A_HDCPCFG1_DISSHA1CHECK_MASK = 0x8,
-	HDMI_A_HDCPCFG1_DISSHA1CHECK_DISABLE = 0x8,
-	HDMI_A_HDCPCFG1_DISSHA1CHECK_ENABLE = 0x0,
-	HDMI_A_HDCPCFG1_PH2UPSHFTENC_MASK = 0x4,
-	HDMI_A_HDCPCFG1_PH2UPSHFTENC_ENABLE = 0x4,
-	HDMI_A_HDCPCFG1_PH2UPSHFTENC_DISABLE = 0x0,
-	HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_MASK = 0x2,
-	HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_DISABLE = 0x2,
-	HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_ENABLE = 0x0,
-	HDMI_A_HDCPCFG1_SWRESET_MASK = 0x1,
-	HDMI_A_HDCPCFG1_SWRESET_ASSERT = 0x0,
-
-	/* A_VIDPOLCFG field values */
-	HDMI_A_VIDPOLCFG_UNENCRYPTCONF_MASK = 0x60,
-	HDMI_A_VIDPOLCFG_UNENCRYPTCONF_OFFSET = 5,
-	HDMI_A_VIDPOLCFG_DATAENPOL_MASK = 0x10,
-	HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_HIGH = 0x10,
-	HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_LOW = 0x0,
-	HDMI_A_VIDPOLCFG_VSYNCPOL_MASK = 0x8,
-	HDMI_A_VIDPOLCFG_VSYNCPOL_ACTIVE_HIGH = 0x8,
-	HDMI_A_VIDPOLCFG_VSYNCPOL_ACTIVE_LOW = 0x0,
-	HDMI_A_VIDPOLCFG_HSYNCPOL_MASK = 0x2,
-	HDMI_A_VIDPOLCFG_HSYNCPOL_ACTIVE_HIGH = 0x2,
-	HDMI_A_VIDPOLCFG_HSYNCPOL_ACTIVE_LOW = 0x0,
-
-	/* I2CM_OPERATION field values */
-	HDMI_I2CM_OPERATION_BUSCLEAR = 0x20,
-	HDMI_I2CM_OPERATION_WRITE = 0x10,
-	HDMI_I2CM_OPERATION_READ_EXT = 0x2,
-	HDMI_I2CM_OPERATION_READ = 0x1,
-
-	/* I2CM_INT field values */
-	HDMI_I2CM_INT_DONE_POL = 0x8,
-	HDMI_I2CM_INT_DONE_MASK = 0x4,
-
-	/* I2CM_CTLINT field values */
-	HDMI_I2CM_CTLINT_NAC_POL = 0x80,
-	HDMI_I2CM_CTLINT_NAC_MASK = 0x40,
-	HDMI_I2CM_CTLINT_ARB_POL = 0x8,
-	HDMI_I2CM_CTLINT_ARB_MASK = 0x4,
-};
-
-/*
- * HDMI 3D TX PHY registers
- */
-#define HDMI_3D_TX_PHY_PWRCTRL 0x00
-#define HDMI_3D_TX_PHY_SERDIVCTRL 0x01
-#define HDMI_3D_TX_PHY_SERCKCTRL 0x02
-#define HDMI_3D_TX_PHY_SERCKKILLCTRL 0x03
-#define HDMI_3D_TX_PHY_TXRESCTRL 0x04
-#define HDMI_3D_TX_PHY_CKCALCTRL 0x05
-#define HDMI_3D_TX_PHY_CPCE_CTRL 0x06
-#define HDMI_3D_TX_PHY_TXCLKMEASCTRL 0x07
-#define HDMI_3D_TX_PHY_TXMEASCTRL 0x08
-#define HDMI_3D_TX_PHY_CKSYMTXCTRL 0x09
-#define HDMI_3D_TX_PHY_CMPSEQCTRL 0x0a
-#define HDMI_3D_TX_PHY_CMPPWRCTRL 0x0b
-#define HDMI_3D_TX_PHY_CMPMODECTRL 0x0c
-#define HDMI_3D_TX_PHY_MEASCTRL 0x0d
-#define HDMI_3D_TX_PHY_VLEVCTRL 0x0e
-#define HDMI_3D_TX_PHY_D2ACTRL 0x0f
-#define HDMI_3D_TX_PHY_CURRCTRL 0x10
-#define HDMI_3D_TX_PHY_DRVANACTRL 0x11
-#define HDMI_3D_TX_PHY_PLLMEASCTRL 0x12
-#define HDMI_3D_TX_PHY_PLLPHBYCTRL 0x13
-#define HDMI_3D_TX_PHY_GRP_CTRL 0x14
-#define HDMI_3D_TX_PHY_GMPCTRL 0x15
-#define HDMI_3D_TX_PHY_MPLLMEASCTRL 0x16
-#define HDMI_3D_TX_PHY_MSM_CTRL 0x17
-#define HDMI_3D_TX_PHY_SCRPB_STATUS 0x18
-#define HDMI_3D_TX_PHY_TXTERM 0x19
-#define HDMI_3D_TX_PHY_PTRPT_ENBL 0x1a
-#define HDMI_3D_TX_PHY_PATTERNGEN 0x1b
-#define HDMI_3D_TX_PHY_SDCAP_MODE 0x1c
-#define HDMI_3D_TX_PHY_SCOPEMODE 0x1d
-#define HDMI_3D_TX_PHY_DIGTXMODE 0x1e
-#define HDMI_3D_TX_PHY_STR_STATUS 0x1f
-#define HDMI_3D_TX_PHY_SCOPECNT0 0x20
-#define HDMI_3D_TX_PHY_SCOPECNT1 0x21
-#define HDMI_3D_TX_PHY_SCOPECNT2 0x22
-#define HDMI_3D_TX_PHY_SCOPECNTCLK 0x23
-#define HDMI_3D_TX_PHY_SCOPESAMPLE 0x24
-#define HDMI_3D_TX_PHY_SCOPECNTMSB01 0x25
-#define HDMI_3D_TX_PHY_SCOPECNTMSB2CK 0x26
-
-/* HDMI_3D_TX_PHY_CKCALCTRL values */
-#define HDMI_3D_TX_PHY_CKCALCTRL_OVERRIDE BIT(15)
-
-/* HDMI_3D_TX_PHY_MSM_CTRL values */
-#define HDMI_3D_TX_PHY_MSM_CTRL_MPLL_PH_SEL_CK BIT(13)
-#define HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_CLK_REF_MPLL (0 << 1)
-#define HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_OFF (1 << 1)
-#define HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_PCLK (2 << 1)
-#define HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_FB_CLK (3 << 1)
-#define HDMI_3D_TX_PHY_MSM_CTRL_SCOPE_CK_SEL BIT(0)
-
-/* HDMI_3D_TX_PHY_PTRPT_ENBL values */
-#define HDMI_3D_TX_PHY_PTRPT_ENBL_OVERRIDE BIT(15)
-#define HDMI_3D_TX_PHY_PTRPT_ENBL_PG_SKIP_BIT2 BIT(8)
-#define HDMI_3D_TX_PHY_PTRPT_ENBL_PG_SKIP_BIT1 BIT(7)
-#define HDMI_3D_TX_PHY_PTRPT_ENBL_PG_SKIP_BIT0 BIT(6)
-#define HDMI_3D_TX_PHY_PTRPT_ENBL_CK_REF_ENB BIT(5)
-#define HDMI_3D_TX_PHY_PTRPT_ENBL_RCAL_ENB BIT(4)
-#define HDMI_3D_TX_PHY_PTRPT_ENBL_TX_CLK_ALIGN_ENB BIT(3)
-#define HDMI_3D_TX_PHY_PTRPT_ENBL_TX_READY BIT(2)
-#define HDMI_3D_TX_PHY_PTRPT_ENBL_CKO_WORD_ENB BIT(1)
-#define HDMI_3D_TX_PHY_PTRPT_ENBL_REFCLK_ENB BIT(0)
-
-struct drm_display_info;
-struct drm_display_mode;
-struct drm_encoder;
-struct dw_hdmi;
-struct platform_device;
-
-enum {
-	DW_HDMI_RES_8,
-	DW_HDMI_RES_10,
-	DW_HDMI_RES_12,
-	DW_HDMI_RES_MAX,
-};
-
-struct dw_hdmi_audio_tmds_n {
-	unsigned long tmds;
-	unsigned int n_32k;
-	unsigned int n_44k1;
-	unsigned int n_48k;
-};
-
-enum dw_hdmi_phy_type {
-	DW_HDMI_PHY_DWC_HDMI_TX_PHY = 0x00,
-	DW_HDMI_PHY_DWC_MHL_PHY_HEAC = 0xb2,
-	DW_HDMI_PHY_DWC_MHL_PHY = 0xc2,
-	DW_HDMI_PHY_DWC_HDMI_3D_TX_PHY_HEAC = 0xe2,
-	DW_HDMI_PHY_DWC_HDMI_3D_TX_PHY = 0xf2,
-	DW_HDMI_PHY_DWC_HDMI20_TX_PHY = 0xf3,
-	DW_HDMI_PHY_VENDOR_PHY = 0xfe,
-};
-
-enum supported_eotf_type {
-	TRADITIONAL_GAMMA_SDR = 0,
-	TRADITIONAL_GAMMA_HDR,
-	SMPTE_ST2084,
-	HLG,
-	FUTURE_EOTF
-};
-
-struct dw_hdmi_mpll_config {
-	unsigned long mpixelclock;
-	struct {
-		u16 cpce;
-		u16 gmp;
-	} res[DW_HDMI_RES_MAX];
-};
-
-struct dw_hdmi_curr_ctrl {
-	unsigned long mpixelclock;
-	u16 curr[DW_HDMI_RES_MAX];
-};
-
-struct dw_hdmi_phy_config {
-	unsigned long mpixelclock;
-	u16 sym_ctr; /*clock symbol and transmitter control*/
-	u16 term; /*transmission termination value*/
-	u16 vlev_ctr; /* voltage level control */
-};
-
-struct dw_hdmi_phy_ops {
-	int (*init)(struct dw_hdmi *hdmi, void *data,
-		    const struct drm_display_info *display,
-		    const struct drm_display_mode *mode);
-	void (*disable)(struct dw_hdmi *hdmi, void *data);
-	enum drm_connector_status (*read_hpd)(struct dw_hdmi *hdmi, void *data);
-	void (*update_hpd)(struct dw_hdmi *hdmi, void *data, bool force,
-			   bool disabled, bool rxsense);
-	void (*setup_hpd)(struct dw_hdmi *hdmi, void *data);
-};
-
-struct dw_hdmi_property_ops {
-	void (*attatch_properties)(struct drm_connector *connector,
-				   unsigned int color, int version, void *data);
-	void (*destroy_properties)(struct drm_connector *connector, void *data);
-	int (*set_property)(struct drm_connector *connector,
-			    struct drm_connector_state *state,
-			    struct drm_property *property, u64 val, void *data);
-	int (*get_property)(struct drm_connector *connector,
-			    const struct drm_connector_state *state,
-			    struct drm_property *property, u64 *val,
-			    void *data);
-};
-
-struct dw_hdmi_plat_data {
-	struct regmap *regm;
-	unsigned long input_bus_encoding;
-	bool use_drm_infoframe;
-	bool ycbcr_420_allowed;
-	unsigned int output_port;
-	/*
-    ¦* Private data passed to all the .mode_valid() and .configure_phy()
-    ¦* callback functions.
-    ¦*/
-	void *priv_data;
-
-	/* Platform-specific mode validation (optional). */
-	enum drm_mode_status (*mode_valid)(struct dw_hdmi *hdmi, void *data,
-					   const struct drm_display_info *info,
-					   const struct drm_display_mode *mode);
-
-	/* Vendor PHY support */
-	const struct dw_hdmi_phy_ops *phy_ops;
-	const char *phy_name;
-	void *phy_data;
-	unsigned int phy_force_vendor;
-
-	/* Synopsys PHY support */
-	const struct dw_hdmi_mpll_config *mpll_cfg;
-	const struct dw_hdmi_curr_ctrl *cur_ctr;
-	const struct dw_hdmi_phy_config *phy_config;
-	int (*configure_phy)(struct dw_hdmi *hdmi, void *data,
-			     unsigned long mpixelclock);
-	unsigned long (*get_input_bus_format)(void *data);
-	unsigned long (*get_output_bus_format)(void *data);
-	unsigned long (*get_enc_in_encoding)(void *data);
-	unsigned long (*get_enc_out_encoding)(void *data);
-
-	/* Vendor Property support */
-	const struct dw_hdmi_property_ops *property_ops;
-
-	unsigned int disable_cec : 1;
-};
-
-struct dw_hdmi *dw_hdmi_probe(struct platform_device *pdev,
-			      const struct dw_hdmi_plat_data *plat_data);
-void dw_hdmi_remove(struct dw_hdmi *hdmi);
-void dw_hdmi_unbind(struct dw_hdmi *hdmi);
-struct dw_hdmi *dw_hdmi_bind(struct platform_device *pdev,
-			     struct drm_encoder *encoder,
-			     const struct dw_hdmi_plat_data *plat_data);
-
-void dw_hdmi_suspend(struct dw_hdmi *hdmi);
-void dw_hdmi_resume(struct dw_hdmi *hdmi);
-
-void dw_hdmi_setup_rx_sense(struct dw_hdmi *hdmi, bool hpd, bool rx_sense);
-
-int dw_hdmi_set_plugged_cb(struct dw_hdmi *hdmi, hdmi_codec_plugged_cb fn,
-			   struct device *codec_dev);
-void dw_hdmi_set_sample_rate(struct dw_hdmi *hdmi, unsigned int rate);
-void dw_hdmi_set_channel_count(struct dw_hdmi *hdmi, unsigned int cnt);
-void dw_hdmi_set_channel_status(struct dw_hdmi *hdmi, u8 *channel_status);
-void dw_hdmi_set_channel_allocation(struct dw_hdmi *hdmi, unsigned int ca);
-void dw_hdmi_audio_enable(struct dw_hdmi *hdmi);
-void dw_hdmi_audio_disable(struct dw_hdmi *hdmi);
-void dw_hdmi_set_high_tmds_clock_ratio(struct dw_hdmi *hdmi,
-				       const struct drm_display_info *display);
-
-/* PHY configuration */
-void dw_hdmi_phy_i2c_set_addr(struct dw_hdmi *hdmi, u8 address);
-void dw_hdmi_phy_i2c_write(struct dw_hdmi *hdmi, unsigned short data,
-			   unsigned char addr);
-
-void dw_hdmi_phy_gen2_pddq(struct dw_hdmi *hdmi, u8 enable);
-void dw_hdmi_phy_gen2_txpwron(struct dw_hdmi *hdmi, u8 enable);
-void dw_hdmi_phy_reset(struct dw_hdmi *hdmi);
-
-enum drm_connector_status dw_hdmi_phy_read_hpd(struct dw_hdmi *hdmi,
-					       void *data);
-void dw_hdmi_phy_update_hpd(struct dw_hdmi *hdmi, void *data, bool force,
-			    bool disabled, bool rxsense);
-void dw_hdmi_phy_setup_hpd(struct dw_hdmi *hdmi, void *data);
-
-void dw_hdmi_enable_video(struct dw_hdmi *hdmi);
-void dw_hdmi_disable_video(struct dw_hdmi *hdmi);
-#endif /* __DW_HDMI_H__ */
diff --git a/drivers/gpu/drm/eswin/dw_hdmi_hdcp.c b/drivers/gpu/drm/eswin/dw_hdmi_hdcp.c
index 1b4e7433b718..b69b1be14e0d 100644
--- a/drivers/gpu/drm/eswin/dw_hdmi_hdcp.c
+++ b/drivers/gpu/drm/eswin/dw_hdmi_hdcp.c
@@ -22,11 +22,12 @@
 #include <linux/module.h>
 #include <linux/of_device.h>
 #include <linux/spinlock.h>
-#include <linux/soc/eswin/eswin_vendor_storage.h>
+//#include <linux/soc/eswin/eswin_vendor_storage.h>
 #include <linux/uaccess.h>
 #include <linux/fs.h>
 #include <linux/module.h>
-#include "dw_hdmi.h"
+#include <linux/random.h>
+#include "dw-hdmi.h"
 #include "dw_hdmi_hdcp.h"
 
 #define HDCP_KEY_PATH "/usr/hdcp1.4_key/Tx_A2_TestDPK_encrypted"
@@ -484,7 +485,7 @@ static int hdcp_load_keys_cb(struct dw_hdcp *hdcp)
 		return -ENOMEM;
 	}
 #if 1
-	size = eswin_vendor_read(HDMI_HDCP1X_ID, hdcp_vendor_data, 314);
+	// size = eswin_vendor_read(HDMI_HDCP1X_ID, hdcp_vendor_data, 314);
 
 	for (i = 0; i < sizeof(hdcp_vendor_data); i++)
 		hdcp_vendor_data[i] = hdcp_const_data[i];
diff --git a/drivers/gpu/drm/eswin/dw_hdmi_hdcp.h b/drivers/gpu/drm/eswin/dw_hdmi_hdcp.h
index 849de9037652..a4992e8a8cbc 100644
--- a/drivers/gpu/drm/eswin/dw_hdmi_hdcp.h
+++ b/drivers/gpu/drm/eswin/dw_hdmi_hdcp.h
@@ -67,5 +67,4 @@ extern u8 tv_hdmi_hdcp2_support(struct dw_hdmi *hdmi);
 extern void dw_hdmi_hdcp2_init(struct dw_hdcp2 *hdcp2);
 extern void dw_hdmi_hdcp2_remove(void);
 extern void dw_hdmi_hdcp2_start(int enable);
-extern void get_random_bytes(void *buf, int nbytes);
 #endif
diff --git a/drivers/gpu/drm/eswin/dw_hdmi_hdcp2.c b/drivers/gpu/drm/eswin/dw_hdmi_hdcp2.c
index dd553bd9b72e..63ce0ae4fde3 100644
--- a/drivers/gpu/drm/eswin/dw_hdmi_hdcp2.c
+++ b/drivers/gpu/drm/eswin/dw_hdmi_hdcp2.c
@@ -146,8 +146,8 @@ static long load_code(hl_device *hl_dev, struct hl_drv_ioc_code __user *arg)
 		return -EBUSY;
 
 	if (randomize_mem) {
-		prandom_bytes(hl_dev->code, hl_dev->code_size);
-		prandom_bytes(hl_dev->data, hl_dev->data_size);
+		get_random_bytes(hl_dev->code, hl_dev->code_size);
+		get_random_bytes(hl_dev->data, hl_dev->data_size);
 	}
 
 	if (copy_from_user(hl_dev->code, &arg->data, head.len) != 0)
diff --git a/drivers/gpu/drm/eswin/dw_hdmi_i2s_audio.c b/drivers/gpu/drm/eswin/dw_hdmi_i2s_audio.c
index a2f3099b6bd2..e211f8b9ab73 100644
--- a/drivers/gpu/drm/eswin/dw_hdmi_i2s_audio.c
+++ b/drivers/gpu/drm/eswin/dw_hdmi_i2s_audio.c
@@ -9,17 +9,18 @@
 #include <linux/dma-mapping.h>
 #include <linux/module.h>
 
+#include <drm/bridge/dw_hdmi.h>
 #include <drm/drm_crtc.h>
 
 #include <sound/hdmi-codec.h>
 
-#include "dw_hdmi.h"
+#include "dw-hdmi.h"
 #include "dw_hdmi_audio.h"
 
 #define DRIVER_NAME "dw-hdmi-i2s-audio"
 
-static inline void hdmi_write(struct dw_hdmi_i2s_audio_data *audio, u8 val,
-			      int offset)
+static inline void hdmi_write(struct dw_hdmi_i2s_audio_data *audio,
+			      u8 val, int offset)
 {
 	struct dw_hdmi *hdmi = audio->hdmi;
 
@@ -44,7 +45,7 @@ static int dw_hdmi_i2s_hw_params(struct device *dev, void *data,
 	u8 inputclkfs = 0;
 
 	/* it cares I2S only */
-	if (fmt->bit_clk_master | fmt->frame_clk_master) {
+	if (fmt->bit_clk_provider | fmt->frame_clk_provider) {
 		dev_err(dev, "unsupported clock settings\n");
 		return -EINVAL;
 	}
@@ -53,8 +54,8 @@ static int dw_hdmi_i2s_hw_params(struct device *dev, void *data,
 	hdmi_write(audio, HDMI_AUD_CONF0_SW_RESET, HDMI_AUD_CONF0);
 	hdmi_write(audio, (u8)~HDMI_MC_SWRSTZ_I2SSWRST_REQ, HDMI_MC_SWRSTZ);
 
-	inputclkfs = HDMI_AUD_INPUTCLKFS_64FS;
-	conf0 = (HDMI_AUD_CONF0_I2S_SELECT | HDMI_AUD_CONF0_I2S_EN0);
+	inputclkfs	= HDMI_AUD_INPUTCLKFS_64FS;
+	conf0		= (HDMI_AUD_CONF0_I2S_SELECT | HDMI_AUD_CONF0_I2S_EN0);
 
 	/* Enable the required i2s lanes */
 	switch (hparms->channels) {
@@ -157,9 +158,9 @@ static int dw_hdmi_i2s_get_dai_id(struct snd_soc_component *component,
 		return ret;
 
 	/*
-     * HDMI sound should be located as reg = <2>
-     * Then, it is sound port 0
-     */
+	 * HDMI sound should be located as reg = <2>
+	 * Then, it is sound port 0
+	 */
 	if (of_ep.port == 2)
 		return 0;
 
@@ -177,11 +178,11 @@ static int dw_hdmi_i2s_hook_plugged_cb(struct device *dev, void *data,
 }
 
 static const struct hdmi_codec_ops dw_hdmi_i2s_ops = {
-	.hw_params = dw_hdmi_i2s_hw_params,
-	.audio_startup = dw_hdmi_i2s_audio_startup,
-	.audio_shutdown = dw_hdmi_i2s_audio_shutdown,
-	.get_eld = dw_hdmi_i2s_get_eld,
-	.get_dai_id = dw_hdmi_i2s_get_dai_id,
+	.hw_params	= dw_hdmi_i2s_hw_params,
+	.audio_startup  = dw_hdmi_i2s_audio_startup,
+	.audio_shutdown	= dw_hdmi_i2s_audio_shutdown,
+	.get_eld	= dw_hdmi_i2s_get_eld,
+	.get_dai_id	= dw_hdmi_i2s_get_dai_id,
 	.hook_plugged_cb = dw_hdmi_i2s_hook_plugged_cb,
 };
 
@@ -192,18 +193,19 @@ static int snd_dw_hdmi_probe(struct platform_device *pdev)
 	struct hdmi_codec_pdata pdata;
 	struct platform_device *platform;
 
-	pdata.ops = &dw_hdmi_i2s_ops;
-	pdata.i2s = 1;
-	pdata.max_i2s_channels = 8;
-	pdata.data = audio;
+	memset(&pdata, 0, sizeof(pdata));
+	pdata.ops		= &dw_hdmi_i2s_ops;
+	pdata.i2s		= 1;
+	pdata.max_i2s_channels	= 8;
+	pdata.data		= audio;
 
 	memset(&pdevinfo, 0, sizeof(pdevinfo));
-	pdevinfo.parent = pdev->dev.parent;
-	pdevinfo.id = PLATFORM_DEVID_AUTO;
-	pdevinfo.name = HDMI_CODEC_DRV_NAME;
-	pdevinfo.data = &pdata;
-	pdevinfo.size_data = sizeof(pdata);
-	pdevinfo.dma_mask = DMA_BIT_MASK(32);
+	pdevinfo.parent		= pdev->dev.parent;
+	pdevinfo.id		= PLATFORM_DEVID_AUTO;
+	pdevinfo.name		= HDMI_CODEC_DRV_NAME;
+	pdevinfo.data		= &pdata;
+	pdevinfo.size_data	= sizeof(pdata);
+	pdevinfo.dma_mask	= DMA_BIT_MASK(32);
 
 	platform = platform_device_register_full(&pdevinfo);
 	if (IS_ERR(platform))
@@ -214,24 +216,23 @@ static int snd_dw_hdmi_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int snd_dw_hdmi_remove(struct platform_device *pdev)
+static void snd_dw_hdmi_remove(struct platform_device *pdev)
 {
 	struct platform_device *platform = dev_get_drvdata(&pdev->dev);
 
 	platform_device_unregister(platform);
-
-	return 0;
 }
 
 struct platform_driver snd_dw_hdmi_driver = {
-    .probe  = snd_dw_hdmi_probe,
-    .remove = snd_dw_hdmi_remove,
-    .driver = {
-        .name = DRIVER_NAME,
-    },
+	.probe	= snd_dw_hdmi_probe,
+	.remove_new = snd_dw_hdmi_remove,
+	.driver	= {
+		.name = DRIVER_NAME,
+	},
 };
 //module_platform_driver(snd_dw_hdmi_driver);
 
+MODULE_AUTHOR("Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>");
 MODULE_DESCRIPTION("Synopsis Designware HDMI I2S ALSA SoC interface");
 MODULE_LICENSE("GPL v2");
 MODULE_ALIAS("platform:" DRIVER_NAME);
diff --git a/drivers/gpu/drm/eswin/es_drv.c b/drivers/gpu/drm/eswin/es_drv.c
index 1d15deda7c7b..885b8d6fa5ab 100644
--- a/drivers/gpu/drm/eswin/es_drv.c
+++ b/drivers/gpu/drm/eswin/es_drv.c
@@ -32,7 +32,7 @@
 #include "es_dc.h"
 #include "es_virtual.h"
 #ifdef CONFIG_ESWIN_DW_HDMI
-#include "dw_hdmi.h"
+#include "dw-hdmi.h"
 #endif
 
 #define DRV_NAME "es_drm"
@@ -215,7 +215,7 @@ static int es_drm_create_properties(struct drm_device *dev)
 		return -ENOMEM;
 	private->connector_id_prop = prop;
 
-	return drm_mode_create_tv_properties(dev, 0, NULL);
+	return drm_mode_create_tv_properties(dev, 0);
 }
 #endif
 
diff --git a/drivers/gpu/drm/eswin/eswin_dw_hdmi.c b/drivers/gpu/drm/eswin/eswin_dw_hdmi.c
index 330837047580..36efffa7d47a 100644
--- a/drivers/gpu/drm/eswin/eswin_dw_hdmi.c
+++ b/drivers/gpu/drm/eswin/eswin_dw_hdmi.c
@@ -18,12 +18,14 @@
 #include <drm/drm_simple_kms_helper.h>
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
+#include <drm/bridge/dw_hdmi.h>
 
-#include <uapi/drm/drm_mode.h>
-#include <uapi/linux/videodev2.h>
+#include <drm/drm_mode.h>
+#include <linux/videodev2.h>
+#include <linux/media-bus-format.h>
 #include <linux/pm_runtime.h>
 
-#include "dw_hdmi.h"
+#include "dw-hdmi.h"
 #include "es_drv.h"
 #include "es_crtc.h"
 
@@ -385,9 +387,9 @@ static void dw_hdmi_eswin_select_output(struct drm_connector_state *conn_state,
 
 	switch (hdmi->hdmi_output) {
 	case DRM_HDMI_OUTPUT_YCBCR_HQ:
-		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB444)
+		if (info->color_formats & DRM_COLOR_FORMAT_YCBCR444)
 			*color_format = DRM_HDMI_OUTPUT_YCBCR444;
-		else if (info->color_formats & DRM_COLOR_FORMAT_YCRCB422)
+		else if (info->color_formats & DRM_COLOR_FORMAT_YCBCR422)
 			*color_format = DRM_HDMI_OUTPUT_YCBCR422;
 		else if (conn_state->connector->ycbcr_420_allowed &&
 			 drm_mode_is_420(info, mode))
@@ -397,9 +399,9 @@ static void dw_hdmi_eswin_select_output(struct drm_connector_state *conn_state,
 		if (conn_state->connector->ycbcr_420_allowed &&
 		    drm_mode_is_420(info, mode))
 			*color_format = DRM_HDMI_OUTPUT_YCBCR420;
-		else if (info->color_formats & DRM_COLOR_FORMAT_YCRCB422)
+		else if (info->color_formats & DRM_COLOR_FORMAT_YCBCR422)
 			*color_format = DRM_HDMI_OUTPUT_YCBCR422;
-		else if (info->color_formats & DRM_COLOR_FORMAT_YCRCB444)
+		else if (info->color_formats & DRM_COLOR_FORMAT_YCBCR444)
 			*color_format = DRM_HDMI_OUTPUT_YCBCR444;
 		break;
 	case DRM_HDMI_OUTPUT_YCBCR420:
@@ -408,11 +410,11 @@ static void dw_hdmi_eswin_select_output(struct drm_connector_state *conn_state,
 			*color_format = DRM_HDMI_OUTPUT_YCBCR420;
 		break;
 	case DRM_HDMI_OUTPUT_YCBCR422:
-		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB422)
+		if (info->color_formats & DRM_COLOR_FORMAT_YCBCR422)
 			*color_format = DRM_HDMI_OUTPUT_YCBCR422;
 		break;
 	case DRM_HDMI_OUTPUT_YCBCR444:
-		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB444)
+		if (info->color_formats & DRM_COLOR_FORMAT_YCBCR444)
 			*color_format = DRM_HDMI_OUTPUT_YCBCR444;
 		break;
 	case DRM_HDMI_OUTPUT_DEFAULT_RGB:
@@ -421,10 +423,10 @@ static void dw_hdmi_eswin_select_output(struct drm_connector_state *conn_state,
 	}
 
 	if (*color_format == DRM_HDMI_OUTPUT_DEFAULT_RGB &&
-	    info->edid_hdmi_dc_modes & DRM_EDID_HDMI_DC_30)
+	    info->edid_hdmi_rgb444_dc_modes & DRM_EDID_HDMI_DC_30)
 		support_dc = true;
 	if (*color_format == DRM_HDMI_OUTPUT_YCBCR444 &&
-	    info->edid_hdmi_dc_modes &
+	    info->edid_hdmi_rgb444_dc_modes &
 		    (DRM_EDID_HDMI_DC_Y444 | DRM_EDID_HDMI_DC_30))
 		support_dc = true;
 	if (*color_format == DRM_HDMI_OUTPUT_YCBCR422)
@@ -463,7 +465,7 @@ static void dw_hdmi_eswin_select_output(struct drm_connector_state *conn_state,
 		/* BT2020 require color depth at lest 10bit */
 		*color_depth = 10;
 		/* We prefer use YCbCr422 to send 10bit */
-		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB422)
+		if (info->color_formats & DRM_COLOR_FORMAT_YCBCR422)
 			*color_format = DRM_HDMI_OUTPUT_YCBCR422;
 	}
 
@@ -885,11 +887,11 @@ static int dw_hdmi_eswin_get_property(struct drm_connector *connector,
 		*val = hdmi->hdmi_output;
 	} else if (property == hdmi->color_depth_capacity) {
 		*val = BIT(ESWIN_HDMI_DEPTH_8);
-		if (info->edid_hdmi_dc_modes & DRM_EDID_HDMI_DC_30)
+		if (info->edid_hdmi_rgb444_dc_modes & DRM_EDID_HDMI_DC_30)
 			*val |= BIT(ESWIN_HDMI_DEPTH_10);
-		if (info->edid_hdmi_dc_modes & DRM_EDID_HDMI_DC_36)
+		if (info->edid_hdmi_rgb444_dc_modes & DRM_EDID_HDMI_DC_36)
 			*val |= BIT(ESWIN_HDMI_DEPTH_12);
-		if (info->edid_hdmi_dc_modes & DRM_EDID_HDMI_DC_48)
+		if (info->edid_hdmi_rgb444_dc_modes & DRM_EDID_HDMI_DC_48)
 			*val |= BIT(ESWIN_HDMI_DEPTH_16);
 		if (info->hdmi.y420_dc_modes & DRM_EDID_YCBCR420_DC_30)
 			*val |= BIT(ESWIN_HDMI_DEPTH_420_10);
@@ -899,12 +901,12 @@ static int dw_hdmi_eswin_get_property(struct drm_connector *connector,
 			*val |= BIT(ESWIN_HDMI_DEPTH_420_16);
 	} else if (property == hdmi->output_format_capacity) {
 		*val = BIT(DRM_HDMI_OUTPUT_DEFAULT_RGB);
-		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB444)
+		if (info->color_formats & DRM_COLOR_FORMAT_YCBCR444)
 			*val |= BIT(DRM_HDMI_OUTPUT_YCBCR444);
-		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB422)
+		if (info->color_formats & DRM_COLOR_FORMAT_YCBCR422)
 			*val |= BIT(DRM_HDMI_OUTPUT_YCBCR422);
 		if (connector->ycbcr_420_allowed &&
-		    info->color_formats & DRM_COLOR_FORMAT_YCRCB420)
+		    info->color_formats & DRM_COLOR_FORMAT_YCBCR420)
 			*val |= BIT(DRM_HDMI_OUTPUT_YCBCR420);
 	} else if (property == config->hdr_output_metadata_property) {
 		*val = state->hdr_output_metadata ?
diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index 6a46baa0737c..85bab1773f38 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -160,6 +160,13 @@ struct dw_hdmi_plat_data {
 	const struct dw_hdmi_phy_config *phy_config;
 	int (*configure_phy)(struct dw_hdmi *hdmi, void *data,
 			     unsigned long mpixelclock);
+	unsigned long (*get_input_bus_format)(void *data);
+	unsigned long (*get_output_bus_format)(void *data);
+	unsigned long (*get_enc_in_encoding)(void *data);
+	unsigned long (*get_enc_out_encoding)(void *data);
+
+	/* Vendor Property support */
+	const struct dw_hdmi_property_ops *property_ops;
 
 	unsigned int disable_cec : 1;
 };
-- 
2.47.0

